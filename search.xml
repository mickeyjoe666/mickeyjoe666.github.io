<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java SE 11 Gold学习笔记(第一章)</title>
    <url>/2020/10/18/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%80%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><ul>
<li><h4 id="第一章-Javaのクラス設計"><a href="#第一章-Javaのクラス設計" class="headerlink" title="第一章 Javaのクラス設計"></a>第一章 Javaのクラス設計</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li><p>A         アクセサ（供外部访问的手段的方法）堅牢性　保守性两方面的优点</p>
</li>
<li><p>C        </p>
</li>
<li><p>A❌</p>
<ol>
<li>A答案说反了。           D⭕️        </li>
</ol>
</li>
<li><p>D</p>
</li>
<li><p>BC</p>
</li>
<li><p>D</p>
</li>
<li><p>A</p>
</li>
<li><p>D❌           B⭕️ </p>
<ol>
<li>hashcode方法是为了搜索object速度加快而提供的。</li>
<li>hashcode最好和equals方法一起override，否则会出现一些预想以外的bug。</li>
</ol>
</li>
<li><p>BE❌         BD⭕️ </p>
<ol>
<li>final 类不能继承，final函数不能重写，final变量不能更改值。</li>
<li>local变量也可以使用final，因此方法的参数可以使用final。</li>
</ol>
</li>
<li><p>D</p>
</li>
<li><p>C</p>
</li>
<li><p>AF❌        DF⭕️</p>
<ol>
<li>singleton是确保一个类的instance不生成一个以上的时候的设计模式。</li>
<li>跟Serializable接口没关系。</li>
</ol>
</li>
<li><p>C</p>
</li>
<li><p>BC</p>
</li>
<li><p>A</p>
</li>
<li><p>C❌         A⭕️</p>
<ol>
<li>菱形继承问题最下面的类会优先选择离得最近的方法。</li>
</ol>
</li>
<li><p>A</p>
</li>
<li><p>E   关于内部class的种类。</p>
</li>
<li><p>D  需要2次确认</p>
</li>
<li><p>C❌          D⭕️　匿名类的声明方式。</p>
</li>
<li><p>C</p>
</li>
<li><p>E❌          B⭕️ top level的列举型只能被public所修饰。</p>
</li>
<li><p>BD❌         AC⭕️ 列举类的定数名字取得的方法是 name 和toString，一般选择重写toString,相反，通过文字列获取值的方法是valueOf。</p>
</li>
<li><p>B      </p>
<ol>
<li>int ordinal()是获取枚举定数的序数的方法。</li>
<li><code>valueOf(Class&lt;T&gt; type , String name)</code>方法。？用法未知</li>
</ol>
</li>
<li><p>B❌            AC⭕️</p>
<ol>
<li>列举型的构造函数只能是private的。并且，不能声明无参的构造方法。</li>
<li>到底能不能定义setter？为什么没报错？（貌似可以在运行时改枚举常数的field值，但是不推荐这么做。）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Size size = Size.L;</span><br><span class="line">    size.setValue(<span class="number">2</span>);</span><br><span class="line">    System.out.println(size.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Gold学习笔记(第七章)</title>
    <url>/2020/12/28/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%83%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>❌⭕️</p>
<ul>
<li><h4 id="第七章-Java-I-O"><a href="#第七章-Java-I-O" class="headerlink" title="第七章　Java I/O"></a>第七章　Java I/O</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li><p>BC❌⭕️CE</p>
<ol>
<li><p>File类能操纵文件或者目录，但是不能对文件的数据进行读取和书写，因此选项B错误。</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3n89sshkj30wu0a2mya.jpg" alt="スクリーンショット 0002-12-28 午後5.20.10">生成File object的四种构造方法，一般指定pathname的用的是最多的。</p>
</li>
<li><p>不存在的文件或路径的File object生成也是可能的。要确认文件或者路径是否存在可以使用exist方法。下图是File类的常用方法。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3ndty2t5j30z10u0jzn.jpg" alt="スクリーンショット 0002-12-28 午後5.25.28"></p>
<p>Java SE 7开始，由于NIO.2的导入，比起File类，推荐使用Path接口。</p>
</li>
</ol>
</li>
<li><p>B❌⭕️C</p>
<ol>
<li>java的IO是不分输出种类的。</li>
<li>有四个抽象类（InputStream, OutputStream, Reader, Writer）提供最基本的方法，针对于device和处理对象，通过各种子类进行继承实现。</li>
</ol>
</li>
<li><p>C</p>
<ol>
<li><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3nrauf2yj30u00u0whg.jpg" alt="6581609144708_.pic"></li>
</ol>
</li>
<li><p>C</p>
<ol>
<li>text file一字一字读取时使用FileReader和FileWriter，一行一行读取时使用BufferedReader，BufferedWriter。</li>
<li>到达文件终端时返回null</li>
<li>写文件的时候注意换行！</li>
</ol>
</li>
<li><p>D❌⭕️B</p>
<ol>
<li>装饰模式</li>
</ol>
</li>
<li><p>B</p>
<ol>
<li><p>InputStream和Reader类在读取数据时，对位置操作的三个方法</p>
<ol>
<li><p>void mark(int readlimit)对现在位置进行mark,参数是可以读取的文字数的上限。</p>
</li>
<li><p>void reset() 回到mark位置，如果没有设置mark位置就reset，会导致IO Exception(Stream not marked)</p>
</li>
<li><p>long skip(long n) 跳过n byte的数据</p>
<p>注意：不是所有的stream都支持mark，可使用markSupported方法来确认是否支持</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>AC❌⭕️AB</p>
<ol>
<li>关于PrintStream和PrintWriter的使用</li>
</ol>
</li>
<li><p>D❌⭕️C</p>
<ol>
<li>System使用console时是通过System.console()来使用</li>
</ol>
</li>
<li><p>B❌⭕️D</p>
<ol>
<li>console.readPassword的返回值类型是char[ ]。</li>
</ol>
</li>
<li><p>BD</p>
<ol>
<li>利用序列化的条件是实现serializable的接口(marker interface，主要起标记作用，不含有成员变量也不含有方法)</li>
<li>默认所有的类都是不可序列化的。</li>
</ol>
</li>
<li><p>A❌⭕️D</p>
<ol>
<li>序列化和反序列化使用的类是ObjectOutputStream和ObjectInputStream</li>
</ol>
</li>
<li><p>C</p>
<ol>
<li>static和transient的变量不会被序列化。</li>
</ol>
</li>
<li><p>C❌⭕️D</p>
<ol>
<li>Java SE 7导入了NIO.2 其中的path接口解决了以前File类的一些问题。</li>
</ol>
</li>
<li><p>C</p>
<ol>
<li><p>FileSystems的getDefault方法用来取得platform的default file system。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    FileSystem fileSystem =  FileSystems.getDefault();</span><br><span class="line">    System.out.println(fileSystem); <span class="comment">//sun.nio.fs.MacOSXFileSystem@2c8d66b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>BD</p>
<ol>
<li>获取Path object的两个方法，<code>FileSystems.getDefault().getPath(&quot;path&quot;)</code>和<code>Paths.get(&quot;path&quot;)</code></li>
</ol>
</li>
<li><p>B❌⭕️D</p>
<ol>
<li>File object到 Path object的转换可使用File的toPath 方法。</li>
</ol>
</li>
<li><p>B❌⭕️D</p>
<ol>
<li>Path的四种方法</li>
<li><code>getRoot()</code> 返回root路径，结果包含path的区分号，例如（¥）</li>
<li><code>getName(int index)</code> 返回index所对应的阶层的path，离root最近的index是0，之后越深一个阶层index增加1。</li>
<li><code>getFileName()</code> 返回最下层的path，注意不光是文件名字，阶层名也可以包括。当只有root 是该方法返回值是null。</li>
<li><code>getNameCount()</code>返回path中包含的阶层数，注意不包含root，当只有root阶层时，返回0。</li>
</ol>
</li>
<li><p>A❌⭕️B</p>
<ol>
<li>Path接口<code>Path subPath(int beginIndex, int endIndex)</code>方法的使用。subPath方法用于截取原path中的一部分，注意离root最近的index是0，注意endIndex指定的结果不包含因此不会被返回。</li>
</ol>
</li>
<li><p>A❌⭕️E</p>
<ol>
<li><p><code>resolve()</code>根据参数不同，返回值也不同。</p>
<ol>
<li><p>相对path,将两个path结合后返回。</p>
</li>
<li><p>绝对path,直接返回参数</p>
</li>
<li><p>空值，返回自身的path</p>
<p>注意区别绝对路径和相对路径</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>B❌⭕️C</p>
<ol>
<li><code>resolveSibling()</code>根据参数不同结果也不同<ol>
<li>相对path,现在path的父path开始的path返回</li>
<li>绝对path,直接返回参数</li>
<li>当call method的path object表示的object是相对path时，返回参数？？</li>
</ol>
</li>
</ol>
</li>
<li><p>A❌⭕️D</p>
<ol>
<li><code>normalize()</code>方法是除去现在path的冗长化，返回正规method的path<ol>
<li>注意<code>.</code>表示当前路径，因此可以忽略，<code>..</code>表示父路径</li>
</ol>
</li>
</ol>
</li>
<li><p>C❌⭕️D</p>
<ol>
<li><code>relativize()</code>方法返回的是针对现在的path，参数的path的相对path。</li>
</ol>
</li>
<li><p>B</p>
</li>
<li><p>AC❌⭕️CD</p>
<ol>
<li>file的copy和移动使用Files的copy和move方法<ol>
<li>copy的default动作是有重复的文件时丢出例外。如果对象是目录，那么目录中有文件存在的情况下文件不会被copy</li>
<li>symbolic link被复制的情况，一般copy的是link指向的文件，link不会被copy</li>
</ol>
</li>
</ol>
</li>
<li><p>BDE❌⭕️BCD</p>
<ol>
<li>BasicFileAttributes以及它的两个子接口：DosFileAttributes,PosixFileAttribute是用来操纵文件属性的</li>
</ol>
</li>
<li><p>C❌⭕️A</p>
<ol>
<li>AttributeView的使用</li>
</ol>
</li>
<li><p>A❌⭕️D</p>
<ol>
<li>取得文件或者目录的单一文件属性的时候可用Files类的getAttribute方法。</li>
<li><code>static Object grtAttribute(Path path, String attribute, LinkOption... options)</code>返回值是Object类型，因此需要cast，第二参数的写法是<code>属性view名:属性名</code>，属性view可以省略</li>
</ol>
</li>
<li><p>D❌⭕️C</p>
<ol>
<li>walkFileTree方法可以对目录进行遍历处理。</li>
</ol>
</li>
<li><p>B</p>
<ol>
<li>使用lines方法将文件中的内容读取为<code>Stream&lt;String&gt;</code>的object</li>
</ol>
</li>
<li><p>A</p>
<ol>
<li>list方法不是递归的，只判断指定目录的文件和目录</li>
<li>list的参数只能是目录，将文件的path传递给list方法时会抛出java.nio.file.NotDirectoryException异常</li>
</ol>
</li>
<li><p>B</p>
<ol>
<li>walk命令是深度优先的递归操作</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Gold学习笔记(第三章)</title>
    <url>/2020/11/09/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%89%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>❌⭕️</p>
<ul>
<li><h4 id="第三章-ラムダ式と組込み関数型インタフェース"><a href="#第三章-ラムダ式と組込み関数型インタフェース" class="headerlink" title="第三章 ラムダ式と組込み関数型インタフェース"></a>第三章 ラムダ式と組込み関数型インタフェース</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li>BCF</li>
<li>C ❌    B⭕️  <ol>
<li>只定义一个抽象方法的接口就称为“函数型接口”。AC选项中的function关键字和接口是不存在的。这个抽象方法被称作Single Abstart Method（SAM）。</li>
</ol>
</li>
<li>BC❌ DE⭕️<ol>
<li>接口中的default方法和static方法不是抽象方法，因此和SAM不干涉。只拥有一个default方法的接口不是函数型接口。</li>
</ol>
</li>
<li>A❌     D⭕️<ol>
<li>java8中追加的@FunctionalInterface注解可以用来判断接口是不是满足函数型接口，即是不是只有一个抽象方法，使用此注解可以避免向被lamda用的前提的设计的接口中追加抽象方法引起的失误。</li>
</ol>
</li>
<li>B</li>
<li>C java的lamda式看上去貌似是将函数代入了参数的位置，实际上代入的是接口的实现object。</li>
<li>D❌    B⭕️<ol>
<li>lamda式中接受参数的部分，可以省略参数的类型，并且当参数只有一个时，可以省略括号（），但是当省略括号的时候，是不能写参数的类型的。</li>
</ol>
</li>
<li>CD<ol>
<li>因为有两个参数，所以无法省略括号。</li>
</ol>
</li>
<li>BC❌ BD⭕️<ol>
<li>lamda式中返回的地方，当省略{}括号时，一定不能写return，相反，当使用{}的时候，一定要写return关键字。</li>
</ol>
</li>
<li>ACEF</li>
<li>A</li>
<li>D</li>
<li>A❌  B⭕️<ol>
<li>Consumer中的抽象方法是void accept(T t)</li>
</ol>
</li>
<li>A❌  C⭕️<ol>
<li>Function中的抽象方法是R apply(T t)</li>
</ol>
</li>
<li>A❌  D⭕️<ol>
<li>BiFunction&lt;T, U, R&gt;的前两个型是参数类型，最后一个R是返回值类型。</li>
</ol>
</li>
<li>D❌  B⭕️<ol>
<li><code>UnaryOperator&lt;T&gt;</code>接口是，提供函数作用为：参数为T型的参数处理后返回T类型的值。这个接口继承了<code>Function&lt;T, T&gt;</code>。</li>
</ol>
</li>
<li>A❌  B⭕️<ol>
<li>提供接受两个相同类型参数，返回相同类型的方法的接口是<code>BinaryOperator&lt;T&gt;</code>,该接口继承了<code>BiFunction&lt;T, T, T&gt;</code>。</li>
</ol>
</li>
<li>B<ol>
<li>method参照的条件是</li>
<li>method参照的几种方式<ol>
<li>类名::方法名（构造函数参照也可以使用，例如<code>Integer::new</code>）</li>
<li>instance变量名::方法名</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Gold学习笔记(第二章)</title>
    <url>/2020/11/03/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%BA%8C%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>❌⭕️</p>
<ul>
<li><h4 id="第二章-コレクションとジェネリクス"><a href="#第二章-コレクションとジェネリクス" class="headerlink" title="第二章 コレクションとジェネリクス"></a>第二章 コレクションとジェネリクス</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li><p>A</p>
</li>
<li><p>E      </p>
</li>
<li><p>D        </p>
</li>
<li><p>AE❌    CE⭕️</p>
<ol>
<li>需要声明变量类型。</li>
<li>等号左右必须类型一致，即便是有多态性关系的类型也不行。java7以后，可以省略等号右边声明。</li>
<li>变量类型不能使用基本类型</li>
<li>右边是匿名类的情况下，不能省略变量类型。</li>
</ol>
</li>
<li><p>FG❌    AG⭕️</p>
<ol>
<li>不能使用instanceof T</li>
<li>不能使用T.class这样来取得泛型的类</li>
<li>泛型变量声明不能带static关键字</li>
<li>不能使用泛型要素生成变量或者数组。</li>
</ol>
</li>
<li><p>B❌   A ⭕️</p>
<ol>
<li>generics method的声明方法为：<code>&lt;型parameter&gt; 返回值类型 方法名（参数list）&#123;方法体&#125;</code></li>
<li>注意，在generics method中声明的泛型变量在方法以外不能被使用。</li>
</ol>
</li>
<li><p>A❌   C ⭕️</p>
<ol>
<li><p>泛型的Type Bound 写法为<code>&lt;型变量 extends 型&gt;</code>, 即使是实现接口是也必须使用extends关键字。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generics03</span>&lt;<span class="title">T</span>, <span class="title">U</span> <span class="keyword">extends</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Generics03&lt;Number, Integer&gt; sample = <span class="keyword">new</span> Generics03&lt;&gt; ();</span><br><span class="line"></span><br><span class="line">    Generics03&lt;Number, Number&gt; sample1 = <span class="keyword">new</span> Generics03&lt;&gt; ();</span><br><span class="line"></span><br><span class="line">    Generics03&lt;A, C&gt; sample2 = <span class="keyword">new</span> Generics03&lt;&gt; ();<span class="comment">//A是借口，C是借口的实现类。实现接口的关系也可以通过extends     来体现。</span></span><br><span class="line"><span class="comment">//    Generics03&lt;Number, String&gt; sample2= new Generics03&lt;&gt; ();  没有继承关系因此编译错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>ABD</p>
<ol>
<li><p>在声明泛型变量时可以使用<code>？</code>来表示不特定的类型(&lt;?&gt;相等于&lt;? extends Object&gt;)</p>
<ol>
<li><p>例如<code>Generics03&lt;?, ?&gt; sample3 = new Generics03&lt;&gt;();</code></p>
</li>
<li><p>可以使用两种方法来声明类型的境界值：<code>&lt;? extends T&gt;</code>表示类型的上限是T类型, <code>&lt;? super T&gt;</code>表示类型的下限是T类型</p>
</li>
<li><p>?不能使用在类声明时和instance声明时（变量声明的等号右边）如下会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Generics03&lt;?, ?&gt; sample4 = <span class="keyword">new</span> Generics03&lt;?, ?&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>D❌   A ⭕️</p>
<ol>
<li>没有对泛型进行parameter化。</li>
</ol>
</li>
<li><p>C</p>
</li>
<li><p>AD </p>
<ol>
<li><p>LinkedList和ArrayList的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>LinkedList</th>
<th>ArrayList</th>
</tr>
</thead>
<tbody><tr>
<td>插入速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>随机访问速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<ol start="12">
<li><p>C</p>
</li>
<li><p>E❌   C⭕️</p>
<ol>
<li>(Arrays.asList生成的list是add不可以但是可以set，并且会影响到原来的数组)</li>
</ol>
</li>
<li><p>D</p>
</li>
<li><p>A❌   B ⭕️</p>
<ol>
<li>deque又名双边队列，支持队列两侧的添加和删除。</li>
<li>不支持用index进行要素的访问。</li>
</ol>
</li>
<li><p>AC</p>
<ol>
<li>stack是线程安全的。</li>
<li><code>ArrayDeque&lt;E&gt;</code>不能容纳null要素</li>
<li>FIFO的时候比ArrayDeque比LinkedList快，FILO的时候比stack快。</li>
</ol>
</li>
<li><p>D❌   C ⭕️</p>
<ol>
<li>Set类似与数学的集合，不允许重复要素存在。可以存储null但是只能存1个。</li>
</ol>
</li>
<li><p>BC</p>
<ol>
<li>HashSet是使用哈希表进行要素管理</li>
<li>TreeSet是根据tree构造进行的实现，使得set中的要素带有顺序。</li>
</ol>
</li>
<li><p>D❌   B ⭕️</p>
<ol>
<li>唯一的key对应的value</li>
<li><code>Map&lt;k, v&gt;</code>不是<code>Collection&lt;E&gt;</code>的子接口！！</li>
</ol>
</li>
<li><p>AC</p>
</li>
<li><p>A❌   C ⭕️</p>
<ol>
<li>从map中取出的是Set类型的Map.Entry的集合</li>
</ol>
</li>
<li><p>CE</p>
</li>
<li><p>B❌   E ⭕️ </p>
<ol>
<li>没实现能比较接口的类，在存入TreeSet这种自动比较的集合时会有例外</li>
</ol>
</li>
<li><p>B</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Gold学习笔记(第五章)</title>
    <url>/2020/12/13/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%BA%94%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>❌⭕️</p>
<ul>
<li><h4 id="第五章-例外とアサーション"><a href="#第五章-例外とアサーション" class="headerlink" title="第五章　例外とアサーション"></a>第五章　例外とアサーション</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li>B </li>
<li>C 捕捉例外后再次抛出新的例外的时候，可以使用之前捕捉的例外进行新的例外的构建。</li>
<li>B</li>
<li>B❌⭕️ D  复数个例外同时catch的时候是catch（例外型1|例外型2|例外型3 … 变量）变量只能有一个！！<ol>
<li>也可以多个这种复数catch同时用（应该catch的顺序从左到右）</li>
</ol>
</li>
<li>B❌⭕️A<ol>
<li>多重捕捉的不能是有继承关系的例外，否则会报编译错误。</li>
<li>多重捕捉的变数是自动声明为final的，因此不能在之后声明相同的变量。</li>
</ol>
</li>
<li>A</li>
<li>B<ol>
<li>try-with-resource是可以记述多个open的式子，用；隔开。</li>
</ol>
</li>
<li>A<ol>
<li>try-with-resource可以不记载catch和finally（第一目的不是例外处理，而是关闭resource）</li>
</ol>
</li>
<li>B❌⭕️C<ol>
<li>try-with-resource的参数必须是继承了java.lang.AutoCloseable接口的，或者是子类。可以重写void close() throws Exception方法。</li>
</ol>
</li>
<li>B<ol>
<li>assert （条件式）,当条件式为false时，会抛出java.lang.AssertionError</li>
<li>assert和条件式之间，当条件式被括号围起来是，有没有空格都ok</li>
</ol>
</li>
<li>D❌⭕️A<ol>
<li>AssertionError类的参数可以这样传递：<code>assert 条件式：参数</code></li>
</ol>
</li>
<li>B❌⭕️C<ol>
<li>java -ea option 全称（enableassertions）开启default无效的断言功能</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Gold学习笔记(第八章)</title>
    <url>/2020/12/30/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E5%85%AB%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>❌⭕️</p>
<ul>
<li><h4 id="第八章-並行性"><a href="#第八章-並行性" class="headerlink" title="第八章 並行性"></a>第八章 並行性</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li><p>CDEF❌⭕️ABDE</p>
<ol>
<li>并行collection，thread pool，atomic变量，Semaphore是java.util.concurrent包提供的功能</li>
</ol>
</li>
<li><p>B</p>
<ol>
<li>atomic包提供了一系列保证原子操作的类。</li>
</ol>
</li>
<li><p>ACD</p>
<ol>
<li>java.util包多数的collection class都不是设计为线程安全的。其中也有例如Vector和Hashtable这种设计为线程安全的类。但是由于利用状况可能performance也会变差。</li>
<li>需要记住<code>ConcurrentHashMap</code>, <code>ConcurrentLinkedDeque</code>, <code>CopyonWriteArrayList</code>的使用方法。</li>
</ol>
</li>
<li><p>ACD❌⭕️ABD</p>
<ol>
<li><code>ConcurrentMap</code>的实现类有两个<code>ConcurrentHashMap</code>和<code>ConcurrentSkipListMap</code>。</li>
<li><code>ConcurrentHashMap</code>没有采取锁整个map的方式，而是采用了Lock Striping，在提高了性能上缺点是size和isEmpty方法不一定返回正确的值，而是返回近似值。</li>
<li><code>ConcurrentHashMap</code>迭代操作允许并行访问对要素的变更操作，因此不会抛出<code>ConcurrentModificationException</code>。</li>
</ol>
</li>
<li><p>BD❌⭕️BC</p>
<ol>
<li>在写操作的时候生成原list的复制进行操作后返回。因此在数据量大的时候性能很低。也不会抛出<code>ConcurrentModificationException</code>。</li>
</ol>
</li>
<li><p>C</p>
</li>
<li><p>CD❌⭕️AD</p>
<ol>
<li>Thread类不能实现设置线程数的上限</li>
</ol>
</li>
<li><p>BDE</p>
</li>
<li><p>BD</p>
<ol>
<li><p>Executor接口和它的子接口以及实现类的关系可用下图来表现</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmilkyl52zj31ba0u0q6o.jpg" alt="6691610261151_.pic"></p>
</li>
</ol>
</li>
<li><p>D❌⭕️C</p>
<ol>
<li><p>Executor接口的方法是接收Runnable类型参数没有返回值，方法名为excute的方法。</p>
</li>
<li><p>生成Executor Object的主要factory method</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runable task = <span class="keyword">new</span> MyTask();</span><br><span class="line">Executor executor = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">executor.execute(task);</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<pre><code>![6701610261847_.pic](https://tva1.sinaimg.cn/large/008eGmZEgy1gmilwml2jqj30zg0twjwm.jpg)</code></pre><ol start="11">
<li><p>AB❌⭕️BD</p>
<ol>
<li><p>Runnable接口的实现类不能丢出可check例外。</p>
</li>
<li><p>Callable接口的实现类的运行需要使用Executor接口的子接口的ExecutorService中的submit方法。</p>
<p><code>&lt;T&gt; Future&lt;T&gt; submit (Callable&lt;T&gt; task)</code></p>
<p>Future Object需要做例外处理。可能会丢出两种例外。<code>java.lang.InterruptedException</code>和<code>java.util.concurrent.ExecutionException</code></p>
</li>
</ol>
</li>
<li><p>CD❌⭕️BC</p>
<ol>
<li>Future类可以做对线程的取消操作。</li>
</ol>
</li>
<li><p>CD</p>
</li>
<li><p>BD❌⭕️BC</p>
<ol>
<li>fork/join框架采用了Work stealing 算法</li>
</ol>
</li>
<li><p>B</p>
</li>
<li><p>BCD❌⭕️BCE</p>
<p>ForkJoinPool的三个方法</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmiq46zcyxj30u00u0b2b.jpg" alt="6711610270544_.pic_hd"></p>
</li>
<li><p>A❌⭕️AB</p>
<p>关于RecursiveTask（有返回值）和RecursiveAction（无返回值时使用）的使用区别要注意！！</p>
</li>
<li><p>D❌⭕️C</p>
<ol>
<li>stream运行途中可以改变是否是并行运行的状态。例如：顺序运行→并行运行使用parallel方法。并行运行→顺序运行使用sequential方法。并且可以使用isParallel方法判断当前的运行mode。</li>
<li>因为stream的并行运算依赖于元素数量和处理内容，因此并行运算不一定就比串行运算要快。</li>
<li>运行中保持线程安全的责任在开发者身上，这点要注意。</li>
</ol>
</li>
<li><p>C</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Gold学习笔记(第六章)</title>
    <url>/2020/12/19/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E5%85%AD%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>❌⭕️</p>
<ul>
<li><h4 id="第六章-日付-時刻API"><a href="#第六章-日付-時刻API" class="headerlink" title="第六章　日付/時刻API"></a>第六章　日付/時刻API</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li><p>C ❌⭕️B</p>
<ol>
<li>java.time是提供date和time常用api的包。四个子包为<code>java.time.chrono</code>,<code>java.time.format</code>,<code>java.time.terporal</code>,<code>java.time.zone</code>。</li>
</ol>
</li>
<li><p>D ❌⭕️C</p>
<ol>
<li><p><code>LocalDate.now()</code>方法生成现在时间的instance。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate d = LocalDate.now(); <span class="comment">// 当前日期</span></span><br><span class="line">LocalTime t = LocalTime.now(); <span class="comment">// 当前时间</span></span><br><span class="line">LocalDateTime dt = LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line">System.out.println(d); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">System.out.println(t); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">System.out.println(dt); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>C❌⭕️CD 生成指定日期的of方法，有两种类。推荐使用月份用列举型代入的。</p>
<ol>
<li><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glt4f32shbj30y404ygm1.jpg" alt="スクリーンショット 0002-12-19 午後2.53.38"></li>
</ol>
</li>
<li><p>AD❌⭕️DE</p>
<ol>
<li><code>implements Temporal, TemporalAdjuster,</code>主要继承这两个接口，后者是只有读取专用的，前者是定义读取和写入用方法的接口。（注意写入是生成新的instance！！！）</li>
</ol>
</li>
<li><p>CE❌⭕️BE</p>
<ol>
<li><code>DayOfWeek</code>和<code>Month</code>两种枚举型。</li>
</ol>
</li>
<li><p>C</p>
</li>
<li><p>B</p>
</li>
<li><p>B❌⭕️D</p>
<ol>
<li>从LocalDate中取出到LocalDateTime会因为没有时间信息而报错。</li>
</ol>
</li>
<li><p>D</p>
<ol>
<li><code>public enum ChronoUnit implements TemporalUnit</code></li>
</ol>
</li>
<li><p>D</p>
</li>
<li><p>C❌⭕️A</p>
<ol>
<li><pre><code class="java">System.out.println(ZoneId.systemDefault());
&lt;!--hexoPostRenderEscape:&lt;figure class="highlight plain"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;12. B❌⭕️D&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;    1. Duration是时间的间隔，Period是日期的间隔 这两个类和特定的时间没有关系，因此与时差，timezone这类情报没有关系。&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;13. BE❌⭕️CE&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;    1. DateTimeFormatter没有构造函数，多数使用static field。且immutable，因此线程安全。&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;    2.  例子&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;       &amp;#96;&amp;#96;&amp;#96;java&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;       DateTimeFormatter formatter &amp;#x3D; DateTimeFormatter.BASIC_ISO_DATE;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;       System.out.println(formatter.format(LocalDateTime.now()));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>
</li>
</ol>
</li>
<li><p>A❌⭕️C</p>
<ol>
<li><p>使用ofPattern方法来自己定义想要format的格式</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy----MM----dd&quot;</span>);</span><br><span class="line">System.out.println(dateTimeFormatter.format(LocalDateTime.now())); <span class="comment">//2020----12----19</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>BCE❌⭕️ACE</p>
<ol>
<li><p>instant是瞬间的意思。从1970年1月1日0点开始经过秒数。</p>
</li>
<li><p>可生成Instant instance的几种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Instant instant1 = ZonedDateTime.now().toInstant();</span><br><span class="line"></span><br><span class="line">Instant instant2 = LocalDateTime.now().toInstant(ZoneOffset.UTC);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Gold学习笔记(第四章)</title>
    <url>/2020/12/05/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E5%9B%9B%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>❌⭕️</p>
<ul>
<li><h4 id="第四章-Stream-API"><a href="#第四章-Stream-API" class="headerlink" title="第四章　Stream API"></a>第四章　Stream API</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li><p>CD</p>
</li>
<li><p>AC ❌   ⭕️CD </p>
<ol>
<li>中端操作的实际进行是在终端操作被实行的时候，这也可称为迟延评价。</li>
<li>终端操作是对stream最后的行为。因此经过终端操作处理的最后不能在被进行stream处理。</li>
<li>中端操作不是必须的，但终端操作是一定要有的。</li>
<li>中端操作一定会返回Stream object，但终端操作不一定。</li>
</ol>
</li>
<li><p>AC</p>
</li>
<li><p>D❌   ⭕️A</p>
<ol>
<li>Collection接口中追加了defalut方法stream()，将包含collection object相同类型的stream object生成返回</li>
</ol>
</li>
<li><p>D</p>
</li>
<li><p>A❌   ⭕️D</p>
<ol>
<li><p>forEach是终端操作，不能对同一个Stream使用两遍。会丢出IllegalStateException</p>
</li>
<li><p>sample</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"><span class="comment">    at java.base/java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:279)</span></span><br><span class="line"><span class="comment">    at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658)</span></span><br><span class="line"><span class="comment">    at chapter04.ForeachMethod.main(ForeachMethod.java:17)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>D</p>
<ol>
<li><p>sample</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">hashMap.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">hashMap.put(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(hashMap);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">hashMap.forEach((k, v) -&gt; System.out.println(k + v));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>C</p>
<ol>
<li><p>sample</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Array类的几种stream方法</span></span><br><span class="line"><span class="keyword">int</span>[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">double</span>[] doubleArray = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line"><span class="keyword">long</span>[] longArray = &#123;<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>&#125;;</span><br><span class="line">Object[] objectArray = &#123;<span class="keyword">new</span> HashMap&lt;&gt;(), <span class="keyword">new</span> ArrayList(), <span class="keyword">new</span> Arrays[]&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">IntStream intStream = Arrays.stream(intArray);</span><br><span class="line">DoubleStream doubleStream = Arrays.stream(doubleArray);</span><br><span class="line">LongStream longStream = Arrays.stream(longArray);</span><br><span class="line">Stream&lt;Object&gt; objectStream = Arrays.stream(objectArray);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>C</p>
</li>
<li><p>AF</p>
<ol>
<li><p>sample</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">5</span>).forEach(System.out::print); <span class="comment">//1234</span></span><br><span class="line">IntStream.rangeClosed(<span class="number">1</span>, <span class="number">5</span>).forEach(System.out::print);<span class="comment">//12345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>B Stream.of( )方法的使用。</p>
</li>
<li><p>B❌   ⭕️BD</p>
<ol>
<li>从text file中读取文字列到Stream object的方法有两种，java.io.BufferedReader类和java.nio.file.Files类的lines方法，但是参数不同。</li>
</ol>
</li>
<li><p>D stream类的常用方法，filter过滤方法。</p>
</li>
<li><p>A</p>
</li>
<li><p>A❌   ⭕️C</p>
<ol>
<li>Stream的排序函数是sorted，不含参数的是按自然顺序排序，含参数的是<code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; )c</code></li>
</ol>
</li>
<li><p>D❌   ⭕️C</p>
<ol>
<li>TreeSet生成时，构造函数的参数应有比较器的object，这道题考的是Comparable的comparing方法，参数应该是生成返回用来sort的key的Function的实现object。因此，get方法符合要求。</li>
</ol>
</li>
<li><p>A❌   C   这道题是关于stream内部的运行顺序，每个对象的处理并不是并行的，banana结束过后才处理apple。peek方法可用在stream中端处理时debug</p>
<ol>
<li><p>sample</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line">        .filter(e -&gt; e.length() &gt; <span class="number">5</span>)</span><br><span class="line">        .peek(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>))</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .peek(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> count = stream.count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//result</span></span><br><span class="line"><span class="comment">//OKbanana BANANA orange ORANGE </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>ABC</p>
</li>
<li><p>B allMatch方法相当于&amp;&amp;运算</p>
</li>
<li><p>D</p>
<ol>
<li>flatMap是将stream平坦化的方法。</li>
</ol>
</li>
<li><p>F❌   D</p>
<ol>
<li>map接口新追加的merge方法有三个参数（key, value, BiFunction），第三个函数是当指定的键在map中存在，并且对应的value不为null时，才会被使用。</li>
<li>当key不存在时，直接将指定的键值对插入。</li>
</ol>
</li>
<li><p>C❌   B</p>
<ol>
<li>将数据的集合变为一个的处理，在java中叫做リダクション，比如比较常见的reduction操作有count,max,min等等</li>
<li>减少操作是终端操作。</li>
</ol>
</li>
<li><p>D❌   ⭕️E</p>
<ol>
<li>reduce方法是可以通过开发者定义的reduction操作。reduce有3个重载。</li>
</ol>
</li>
<li><p>A   实现可变reduction操作的object叫做收集器（collector）Stream类的collect有以下两种</p>
<ol>
<li><p>collect方法1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure>

<p>collect方法2</p>
</li>
<li><pre><code class="java">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span>
<span class="function"><span class="params">              BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span>
<span class="function"><span class="params">              BiConsumer&lt;R, R&gt; combiner)</span></span>;</code></pre>
</li>
<li><p>Collectors类提供了很多可变的reduction的static方法。 </p>
</li>
</ol>
</li>
<li><p>D</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第一章)</title>
    <url>/2020/07/17/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%80%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<p>所在部门的要求下，本Java菜鸟也要备战人生中第一个编程技术资格考试了。这个考试的费用接近3万日币（1800RMB左右），如果没通过就要全额自己支付，因此压力还是蛮大的。并且需要死记硬背的东西很多，而我最讨厌死记硬背的学习模式，所以才有了这篇博文。希望写这篇博文可以帮助自己归纳知识点，并且能够帮助那些看到此博文一样在备考的Java coder们。</p>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>我使用的是《Java SE 11 Sliver問題集》这本书，也就是俗称的“黒本”，该书共有13章，并附带三套模拟习题，接下来，我将对每章易错的知识点尝试进行归纳和总结。</p>
<ul>
<li><h4 id="第一章-簡単なJavaプログラムの作成"><a href="#第一章-簡単なJavaプログラムの作成" class="headerlink" title="第一章 簡単なJavaプログラムの作成"></a>第一章 簡単なJavaプログラムの作成</h4></li>
</ul>
<p>間違えた：3, 7</p>
<p>間違えし易い：</p>
<p>分からない：8, </p>
<ol>
<li>略</li>
<li>略</li>
<li><code>java.lang</code>包和<code>System</code>这两个包是会自动被import的，不需要手动声明。另外，在导入包时<code>*</code>表示导入指定包的全部class，但不能包含指定包下的子包！！</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li>java SE 11以后，可以直接使用<code>java Sample.java a b c</code>对Sample.java直接运行。<ol>
<li>对于没有<code>.java</code>扩展名的文件使用<code>java</code>命令运行时需要加<code>--source</code>option进行运行，并可在后面直接指定java版本，例如<code>java --source 11 Sample a b c</code>, 用source模式运行时即使public的类名和文件名不一致也不会报错。</li>
<li>对于没有11以前的版本需要先使用<code>javac</code>命令进行编译。</li>
<li>对于文件名和类名不一样的java文件用<code>javac</code>命令编译时会报错。</li>
</ol>
</li>
<li><code>java</code>命令的参数指定问题<ol>
<li>通常使用空格进行参数的区分，当想传递含有空格的参数时要使用<code>双引号（&quot;&quot;）</code>进行escape。</li>
<li>当想使用双引号是需要在前面加入<code>¥符号</code>进行escape。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第七章)</title>
    <url>/2020/07/26/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%83%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第七章-クラスの継承、インタフェース、抽象クラス"><a href="#第七章-クラスの継承、インタフェース、抽象クラス" class="headerlink" title="第七章 クラスの継承、インタフェース、抽象クラス"></a>第七章 クラスの継承、インタフェース、抽象クラス</h4><p>間違えた：3, 4, 8, 10, 11, 12, 17, 19, 20, 21</p>
<p>間違えし易い：13，20</p>
<p>分からない：全部</p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li><p>继承的概念，子类中没有定义的要去父类中寻找。</p>
</li>
<li><p>继承的原则，不会被继承的为：</p>
<ol>
<li>父类的构造方法</li>
<li>父类的private的变量和方法</li>
</ol>
<p>因此在子类的非继承方法中，是不能访问父类的private的变量的。</p>
</li>
<li><p>接口（interface）的说明。</p>
<ol>
<li>接口中的方法即使不写访问修饰符，也会自动编译为<code>public</code>，这是因为便于其他的类访问。并且接口的抽象方法是不能被<code>protected</code>或者<code>private</code>修饰。</li>
<li>接口是不能instance化的，只能被其他的类实现。并且一个类可以实现多个接口，用逗号区分开即可。</li>
<li>接口中的方法不能有方法体，也就是不能写<code>&#123;&#125;</code>。</li>
<li>接口中可以定义filed，但是要满足两个条件（全部？）：<ol>
<li>用<code>final</code>修饰的，也就是定值。</li>
<li>用<code>static</code>修饰的，不需要instance化就可以访问的。</li>
</ol>
</li>
<li>接口可以扩张。也就是接口可以继承其他的接口，使用<code>extends</code>关键字即可。</li>
</ol>
</li>
<li><p>Java8后，接口可以有静态方法和方法体了,写法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> 返回值 方法名（参数类型 参数名）&#123;</span><br><span class="line">  some code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.Object</code>类中定义的方法不能被接口所重写。否则会出现编译错误。</p>
</li>
<li><p>使用接口的default方法时的写法为：<code>接口名.super.methodName()</code>。但是只能在直接实现接口的类中使用，不能在两次实现或者两次继承中使用！！</p>
</li>
<li><p>在接口的多重实现类中，使用接口的default方法时，如果方法同名，首先要override后在方法体中指定具体实现哪个接口的default方法。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A.<span class="keyword">super</span>.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>抽象类也可以继承抽象类，因此抽象类的方法不一定是所有子类都需要实现。（如果是被抽象类继承就不需要实现）</p>
</li>
<li><p>抽象类中的抽象方法没有方法体，因此执行的是子类中被重写的方法。</p>
</li>
<li><p>重写：方法名，参数类型，数量，顺序都不能改变。从java SE 5开始，返回值可以更改了？</p>
</li>
<li><p>重写的三个规则：</p>
<ol>
<li>シグニチャ（签名）必须相同。</li>
<li>返回值为相同类型，或者为父类返回值类型的子类。</li>
<li>访问权限词相同，或者是比父类更松。（例如父类为public，子类就不能用protected）</li>
</ol>
</li>
<li><p>继承时父类和子类可以使用相同的变量名。当父类和子类有同名变量存在时，使用哪个取决于：</p>
<ol>
<li><p>参照变量时，变数的宣言来决定。</p>
</li>
<li><p>被方法呼出时，根据方法的指定。看具体的例子, 输出结果应为<code>AAAA</code>,因为14和15行instance的类型为A，所以打印时使用A类中的val变量，18行和19行因为B类中压根没有print方法，所以使用A类中的print方法，自然也就参照的A类中的val变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  String val = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  String val = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    A b = <span class="keyword">new</span> B();</span><br><span class="line">    System.out.println(a.val);</span><br><span class="line">    System.out.println(b.val);</span><br><span class="line">    a.print();</span><br><span class="line">    b.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>略</p>
</li>
<li><p><a href="https://www.weblio.jp/content/polymorphism">polymorphism</a>相关的问题。遇到多态的问题要确定一下两点：</p>
<ol>
<li>有没有继承关系或者实现关系，具不具备多态性实现的条件。</li>
<li>对instance的限制的类型中，有没有方法的定义。</li>
</ol>
</li>
<li><p>略</p>
</li>
<li><p>向上转型和向下转型相关。向上转型可以自动完成，但是向下转型需要声明。（cast）例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> B(); <span class="comment">//B的向上转型</span></span><br><span class="line">B b = (B) a  ; <span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于java的向下转型，强制向下转型，编译不会报错。但是在运行时，如果对象本身并非是该类型，强制转型，<br>在运行时会报<code>java.lang.ClassCastException</code>。因此只有把子类型赋给父类的引用，然后把该引用向下转型的情况，才不会报错。<br>父类不能强制向下转型！向上转型则是安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          correctDown();</span><br><span class="line">          errorDown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">correctDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        People people=<span class="keyword">new</span> Man();</span><br><span class="line">        System.out.println((Man) people);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类型转换错误，java.lang.ClassCastException: People cannot be cast to Man</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">errorDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        People people=<span class="keyword">new</span> People();</span><br><span class="line">        System.out.println((Man) people);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="18">
<li><p>scope（作用范围）相关问题。<code>this</code>是指向instance自身的用法。在方法中如果有和全局变量相同名的变量，可以在方法中使用局部变量。但是也可以通过<code>this.fieldName</code>来直接使用全局变量。</p>
</li>
<li><p>this的作用域！！！如果父子类变量名重复的情况下想访问父类的成员变量时要使用<code>super</code>关键字！</p>
</li>
<li><p>拥有继承关系时候的构造方法的构建顺序相关问题。需要注意的是：</p>
<ol>
<li><p>首先，子类需要准备父类的instance和子类差分的instance。</p>
</li>
<li><p>首先构建的是“基盘”部分的父类的instance，因此父类的构造方法会先被执行。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();<span class="comment">//编译器会自动加入这一行，确保在构建子类instance前就生成了父类的instance。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String )</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();<span class="comment">//输出结果为：A，B    </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="21">
<li>在构造方法中想要使用被重载的其他的构造方法时用<code>this</code>关键字，想使用父类的构造方法时要用<code>super</code>关键字。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第三章)</title>
    <url>/2020/07/18/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%89%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第三章-演算子と判定構造"><a href="#第三章-演算子と判定構造" class="headerlink" title="第三章 演算子と判定構造"></a>第三章 演算子と判定構造</h4><p>間違えた：3, 5, 6, 10, 12, 13, 20 </p>
<p>間違えし易い：3, 19</p>
<p>分からない：2</p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li><p>略</p>
</li>
<li><p>-号有两种：1.减法用 2.翻转正负值用（前面有空格也可以）</p>
</li>
<li><p>类型转换问题。</p>
<ol>
<li>注意范围！！如果超出范围也会报错。例如<code>byte a = 128;//byte 范围是-128~127</code>。</li>
<li>注意类型！！整数默认型为<code>int</code>, 浮点小数型默认<code>double</code>。范围来讲，小转大ok，大转小因为会面临丢失精度问题，因此不行。</li>
<li>数值演算时，演算符号两边的operand必须是相同类型，如果是不同类型，范围小的类型会自动转换为大的类型。如果大转小，不做cast表达，会报编译错误。</li>
</ol>
</li>
<li><p>略</p>
</li>
<li><p><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>,<code>&lt;=</code>这四种运算符，只能比较数值的大小，不能用作true和false的比较。</p>
</li>
<li><p><code>&amp;&amp;</code>和<code>&amp;</code>的区别，<code>&amp;&amp;</code>只看左边，一旦左边为false右边不会执行。</p>
</li>
<li><p>演算子的优先顺序：括号，自增，自减是最优先的，<code>x++</code>要比<code>++x</code>优先级高。</p>
</li>
<li><p>java的同一性和同值性的判断问题。</p>
</li>
<li><p>判断是否同值用<code>equals</code>方法。如何判断两个instance是否同值可以通过重写object类的<code>equals</code>方法来完成。</p>
</li>
<li><p>这道题将instance类型转换为object类，因此使用的<code>equals</code>方法不是自己类中重写的<code>equals</code>方法，而是object类中的方法，定义如下,是用来判断同一性的，因此会返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当x为null以外的参照值时，<code>x.equals(null)</code>只能返回false。</p>
</li>
<li><p>常量池（Constant Pool）相关，java中为了避免负荷，当同样文字列的literal出现时，会使用之前生成的instance的参照，因此用==比较结果会返回true。</p>
</li>
<li><p>new的时候会强制生成新的instance，因此和指向常量池内存的变量有不同的值，通过==比较会返回false。</p>
</li>
<li><p>String类的<code>intern</code>方法的问题。intern是返回常量池内存中已有的文字列，为再利用准备的方法。因此即使参照不同，返回的文字列内容是相同的，比较时会返回true。</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>else if中 else和if间是不能改行的。如果改行了，意味着在else中加入新的if条件。</p>
</li>
<li><p>switch的条件的返回值类型为：<code>char</code>,<code>short</code>,<code>Character</code>,<code>Short</code>,<code>String</code>,<code>byte</code>,<code>int</code>,<code>Byte</code>,<code>Integer</code>,<code>Enum</code>。简单来讲分三类</p>
<ol>
<li>int型以下的整数型和他们的包装类。</li>
<li>文字和文字列。</li>
<li>列举型（枚举型）。</li>
</ol>
</li>
<li><p>switch的case值需满足以下三个条件：</p>
<ol>
<li>和条件式的返回值相同类型或者是有互换性的类型。</li>
<li>是定数，在编译时能确定值。</li>
<li>不能为null。</li>
</ol>
</li>
<li><p>switch中如果没有<code>break</code>关键字，将会执行之后的所有case的处理，包括<code>default</code>中的处理。case中什么都不写意味着什么处理都不做，并不会报编译错误。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第九章)</title>
    <url>/2020/08/09/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B9%9D%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第九章-API"><a href="#第九章-API" class="headerlink" title="第九章 API"></a>第九章 API</h4><p>間違えた：2，3，4，6，7，9，12，13，19</p>
<p>間違えし易い：</p>
<p>分からない： 2，15，17</p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li><p><code>Math.pow</code>方法，没什么好说的。第一个参数是累乘对象，第二个是指数。</p>
</li>
<li><p><code>java.util.Comparator</code>接口相关。例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sample[] samples = &#123;</span><br><span class="line">                <span class="keyword">new</span> Sample(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Sample(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Sample(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Sample&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(samples));</span><br><span class="line">          <span class="comment">//实现Comparator接口，自己在定义compare方法进行排序</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> samplecomParator());</span><br><span class="line">        <span class="keyword">for</span> (Sample s: list ) &#123;</span><br><span class="line">              System.out.println(s.getName());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//因为Integer类已经实现了Comparable接口所以可以直接使用集合类的sort方法排序</span></span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">        list2.add(<span class="number">1</span>);</span><br><span class="line">        list2.add(<span class="number">2</span>);</span><br><span class="line">        list2.add(<span class="number">2</span>);</span><br><span class="line">        list2.add(<span class="number">3</span>);</span><br><span class="line">        Collections.sort(list2);</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list2) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">samplecomParator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Sample</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Sample o1, Sample o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.getId() &lt; o2.getId()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o1.getId() &gt; o2.getId()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Sample</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>list.sort()中使用lamda表达式，传入比较方法，题目中想实现的是倒序，而Integer中实现的Comparable接口定义的compareTo是升序，所以要加负号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">compareLamda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line"><span class="comment">//        Collections.sort(list);          //y也可以使用collections类的sort方法，只不过比较慢</span></span><br><span class="line"><span class="comment">//        Collections.reverse(list);</span></span><br><span class="line">        </span><br><span class="line">        list.sort((a, b) -&gt; -a.compareTo(b));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>三种方法参数都是char型因此不会报编译错误。</p>
</li>
<li><p>LocalDate类相关。<code>parse</code>方法传入的是字符串并且连接的必须是<code>-</code>，of方法中月份是从1开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate a = LocalDate.of(<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        LocalDate b = LocalDate.parse(<span class="string">&quot;2015-01-01&quot;</span>);</span><br><span class="line">        System.out.println(a.equals(b));</span><br></pre></td></tr></table></figure>
</li>
<li><p>LocalDate类是immutable的所以调用with方法不会影响之前instance中的值，而是会生成一个新的instance。</p>
</li>
<li><p>ArrayList中是可以存<code>null</code>的，而且可以存重复元素，并且ArrayList是线程不安全的，<code>vector</code>是线程安全的。</p>
</li>
<li><p>不指定类型的ArrayList什么都可以存，除非这样指定的情况下，就是只能存String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Arraylist&lt;String&gt; (); <span class="comment">//Java SE6开始</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Arraylist&lt;&gt; ();       <span class="comment">//Java SE7开始</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于ArrayList的初始化问题，初始化size的长度为0，容量为10？随着加入数据慢慢增加，size也慢慢增加。size指的是存的元素的个数。</p>
</li>
<li><p>ArrayList的set方法，将置换指定index的元素值。</p>
</li>
<li><p>ArrayList的remove方法，从list中删除元素。如果删除的对象有多个存在时，使用<code>equals</code>方法判断<code>true</code>的最初的对象删除。<code>equal</code>方法可以重写。</p>
</li>
<li><p>ArrayList的remove方法后后面的元素会向前移动，注意扩张for是将list中的元素一个一个取出，当删除完时之后的元素如果不再存在for循环将会终止。</p>
</li>
<li><p>ArrayList类的remove方法后不能在将List输出，<a href="https://www.cnblogs.com/dolphin0520/p/3933551.html">原因参考这里</a>，具体内容不需要理解，考试中注意当使用了remove方法后如果使用for循环读取list时会在运行时跳出<code>java.util.ConcurrentModificationException</code>异常。例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        <span class="comment">//错误的</span></span><br><span class="line">        <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;C&quot;</span>.equals(str)) &#123;</span><br><span class="line">                list.remove(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正确的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;C&quot;</span>.equals(list.get(i))) &#123;</span><br><span class="line">                list.remove(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正确的</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;C&quot;</span>.equals(str)) &#123;</span><br><span class="line">                list.remove(str);</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="14">
<li><p>List是不可以变更长度的。</p>
</li>
<li><p>Arrays类的mismatch方法的使用，返回的是两个输入数组最开始不相同元素的index，当两个数组完全相同时返回-1。</p>
</li>
<li><p>Arrays类的compare方法的返回值。因为是String类的compareTo方法，是按按字典顺序进行比较。参考参照最后一个链接。</p>
</li>
<li><p>关于List的removeIf方法，通过传入实现Predicate接口的lamda式（返回值必须为Boolean！！）判断删除的rule。需要注意第7行一开始生成的list不能直接删除，因为Arrays.asList生成的List是不能变更长度的！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">listRemoveIf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;));</span><br><span class="line">        <span class="comment">//Arrays.asList生成的List是不能变更长度的，因此一定要在包装一下</span></span><br><span class="line">        list.removeIf((String s) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.equals(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.runoob.com/java/java8-method-references.html">方法引用</a>。forEach接受的是Consumer型的参数，也就是参数只有1个，没有返回值。此外，关于经常使用的方法，还可以使用方法引用。直接上例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">methodReferences</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Lemon&quot;</span> &#125;;</span><br><span class="line">            Arrays.sort(array, methodReferences::cmp);<span class="comment">//注意方法引用这里不需要加参数！！</span></span><br><span class="line">            Arrays.sort(array, String::compareTo);</span><br><span class="line">            <span class="comment">//因为实例方法有一个隐含的this参数，String类的compareTo()方法在实际调用的时候，第一个隐含参数总是传入                                this，相当于静态方法</span></span><br><span class="line">            System.out.println(String.join(<span class="string">&quot;, &quot;</span>, array));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="19">
<li><p>HashMap类是Map接口的实现类，key和value都可以使用null，并且使用put方法时如果key已经存在了将会覆盖之前的key对应的value而不是新插入元素。null不是存在第0位！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        hashMap.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="number">1</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="keyword">null</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="keyword">null</span>, <span class="string">&quot;new null &quot;</span>);</span><br><span class="line">        hashMap.put(<span class="number">0</span>, <span class="string">&quot;??&quot;</span>);</span><br><span class="line">        System.out.println(hashMap.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://blog.csdn.net/xu962336414/article/details/84032693">ArrayList 集合中怎么插入元素的</a></li>
<li><a href="https://blog.csdn.net/Somhu/article/details/78020547">ArrayList添加元素流程</a></li>
<li><a href="https://blog.csdn.net/m0_37884977/article/details/80514809">ArrayList初始化容量的问题</a></li>
<li><a href="https://www.cnblogs.com/lzq198754/p/5780165.html">Java map 详解 - 用法、遍历、排序、常用API等</a></li>
<li><a href="https://blog.csdn.net/qq_25827845/article/details/53870329">String类中的compareTo方法总结</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3933551.html">Java ConcurrentModificationException异常原因和解决方法</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第二章)</title>
    <url>/2020/07/18/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%BA%8C%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第二章-Javaの基本データ型と文字列操作"><a href="#第二章-Javaの基本データ型と文字列操作" class="headerlink" title="第二章 Javaの基本データ型と文字列操作"></a>第二章 Javaの基本データ型と文字列操作</h4><p>間違えた：1, 3, 4, 6, 7, 12, 17, 20</p>
<p>間違えし易い：2, 5, 19</p>
<p>分からない：2, 3</p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li>java压根没有bool这个数据类型，审题失败。</li>
<li>java除了十进制的表示，还有2进制，8进制，16进制，分别用0b, 0, 0x表示，需要看选项中有没有超过各个进制所能表示<strong>最大位数</strong>的数字！！</li>
<li>下划线出现的规则：<ol>
<li>不能在Literal的先头或者末尾出现</li>
<li>不能在记号的前后出现</li>
</ol>
</li>
<li>文字的Literal必须要用单括号（’’）围起来，文字列的Literal必须要用双括号（””）围起来，并且char可以用0~65535之前的数值代入。且不能直接代入<code>null</code>, 因为在java中<code>null</code>表示什么都不指向，这对java的プリミティブ类型来说是不允许的，因为プリミティブ型就是为了保存变量而存在的。</li>
<li>关于java中变量的命名规则<ol>
<li>不能用预约词和记号</li>
<li>能使用的记号为下划线（<code>_</code>）和通货符号（<code>$</code>）</li>
<li>不能用数字作为开头（第二个字母开始可以，例如<code>v2ex</code>）</li>
</ol>
</li>
<li>关于var变量类型推论的用法：<ol>
<li>首先，<code>var</code>只能对local 变量进行类型推论时使用！！！</li>
<li>在使用<code>var</code>时会根据等号右边的内容对变量的类型进行推论，例如：<code>var a = sample( );</code>尽管右边是函数，但仍然可以使用函数的返回值对变量类型进行推论。但是如果变量没有初始化，或者用<code>null</code>进行初始化，或者不能根据右边的内容进行变量类型推导时，将会在编译时候报错，例如：<code>var a = &#123;1, 2, 3&#125;</code>， 在这里就无法对等号左边a的类型进行确定，因此运行时会发生编译错误。</li>
<li>对于一种特殊情况<code>var e = new ArrayList&lt;&gt;()</code>, 在<code>&lt;&gt;</code>中没有指定类型时java会自动将类型转化为object型，因此相当于<code>var e = new ArrayList&lt;object&gt;()</code>。这样相当于指定了变量e的类型为object型，因此在这种情况下并不会报错。</li>
</ol>
</li>
<li><code>var</code>只能用在局部变量中！并且不能用在函数的参数宣言中，像这种情况下不能根据value的来推断具体的类型，因此会报错：public void test (var value){}```</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li><code>string</code>类的<code>indexOf</code>方法在找不到对应的文字列时，返回值为<code>-1</code>!!!</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li><code>string</code>类的<code>concat</code>方法用来拼接原有文字列和参数传进来的文字列，<code>append</code>方法属于<code>StringBuffer</code>类。</li>
<li>略</li>
<li>略</li>
<li><code>StringBuffer</code>类的无参构造方法会初始化大小为16文字的容量，有文字列作为参数的构造方法会初始化<code>16+参数文字列长度</code>的容量。</li>
<li>略</li>
<li>略</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第五章)</title>
    <url>/2020/07/18/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%BA%94%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第五章-配列の操作-二次"><a href="#第五章-配列の操作-二次" class="headerlink" title="第五章  配列の操作(二次)"></a>第五章  配列の操作(二次)</h4><p>間違えた：1，3，5，6，7，9</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li><p>数组只能存相同类型或者是有互换性的值。并且数组可容纳的要素个数在数组的instance生成的时候被确定，之后是无法变更的。<br>数组存基本型和object型的区别是，基本型是存的数据本身，object是存的参照（指向要素本身的link）。<br><code>println</code>方法是把使用传入参数的<code>toString</code>方法，并将结果打印，数组的toString是继承自object类，内容为将类名和唯一化的instance的hashcode组合值返回。</p>
</li>
<li><p>声明数组变量时，<code>[]</code>既可以写在变量名之前，也可以写在变量名之后，因此分开写（多次元数组两边都写）也是可以的。</p>
</li>
<li><p>由于数组变量只是用来存数组instance的参照，跟具体的数组instance中有多少个元素无关，因此在声明数组变量时，是不能在<code>[]</code>中指定数组的要素个数的。例如<code>int[3]a</code>就会报编译错误。</p>
</li>
<li><p>数组instance生成时，必须要指定要素个数。并且要素的个数只能是整数值。并且要素数的指定只能使用<code>int</code>型，<code>long</code>型也是不能使用的。<br>当生成多元数组的instance时，如果一元和二元分开生成时，第一次元的要素数是无法省略的。例如<br><code>int[][]e = new int[][3]</code>会报错，而<code>int[][]e = new int[2][]</code>就不会。<br>另外，数组变量和生成的instance的次元数也必须一致。一元的要素数和二元的要素数不相同也是可以的。</p>
</li>
<li><p>生成object数组instance时，要注意生成的只是指向object的参照，并不是生成了object本身<br>数组生成时default的值如下表所示</p>
<table>
<thead>
<tr>
<th align="center">型</th>
<th align="center">default值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数型</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">浮点小数型</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center">boolean型</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">文字型</td>
<td align="center">¥u0000</td>
</tr>
<tr>
<td align="center">object</td>
<td align="center">null</td>
</tr>
</tbody></table>
</li>
<li><p>如果想在生成数组instance的时候也对数组的要素值进行初期化时，可以使用初始化符号<code>&#123;&#125;</code><br>null是可以带入String变量的，打印的时候会直接打印null。</p>
</li>
<li><p>生成数组的几种方法。</p>
<ol>
<li>最简单的<code>int[] array = &#123;3, 4&#125;</code></li>
<li><code>int[] array = new int[] &#123;3, 4&#125;</code>注意，在这种情况下，一定要在<code>&#123;&#125;</code>中指定要素的个数，根据大括号中值的个数，决定生成数组的要素数，因此不需要在中括号中写入要素的个数，如果同时写入的话，会报错。</li>
<li>数组变量的次元数和instance中的次元数必须相同，因此这样的code也会报：错<code>int[][] array = new int[]&#123;&#125;</code>。</li>
<li><code>int[][] array = &#123;&#125;</code>不会报错。</li>
<li>初始化符号<code>&#123;&#125;</code>必须要跟变量宣言同时使用。除非明示的将次元数指定了。<br>例如<code>int[][] array; array = new int[][];</code> 就不会报错。但是如果后面改为<code>array = &#123;2, 3&#125;</code>就会报错。</li>
</ol>
</li>
<li><p><code>array.length</code>中的<code>length</code>不是变量，而是在编译时，转换为查数组中要素的个数的命令。类似于方法。</p>
</li>
<li><p>可以生成interface的数组。数组中也可以存interface的实现类，如果是父类的数组，数组中可以存子类。如果是抽象类的数组，可以存实现抽象类的具象类。</p>
</li>
<li><p>可以使用数组的clone方法生成原数组的instance相同的另一个instance。如果是二维数组，一维的instance虽然不同，但是指向的二维的instance是相同的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第六章)</title>
    <url>/2020/07/19/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E5%85%AD%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第六章-インスタンスとメソッド"><a href="#第六章-インスタンスとメソッド" class="headerlink" title="第六章 インスタンスとメソッド"></a>第六章 インスタンスとメソッド</h4><p>間違えた：3, 5, 18, 19, 20, 21, 22, 23, 24, 27, 30</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>在Java中，变量有两种类型，一种是原始类型（プリミティブ型），一种是引用类型。引用型只能有两种（1.保存了向对象的参照link。2.没有保存向对象的参照link）因此像object类型可以代入null，但是打印时打印的是null而不是NULL，更不能把NULL直接代入给object类型的变量。还需要注意文字数为0的空string可以代入给object类型的变量，但是并不等于null，因为null相当于什么也没有指向。</p>
</li>
<li><p>JVM的garbage collector（垃圾回收机制）相关的问题。垃圾回收的时机只能由JVM决定。</p>
<p>对于Java对象来讲，如果说这个对象没有被其他对象所引用该对象就是无用的，此对象就被称为垃圾，其占用的内存也就要被销毁。例如，将null代入给变量的时候，没有被参照的instance就会被销毁。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//在这时,原来生成的instace会没有任何参照</span></span><br></pre></td></tr></table></figure>

<p>其他还有，把变量代入新的instance的参照时，旧的instance就会变成没有参照的对象，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj = <span class="keyword">new</span> Object(); <span class="comment">//在这时，obj对instance的参照会被overwrite</span></span><br></pre></td></tr></table></figure>

<p>疑问：第四行的b也被赋予了null，原来b所指向的instance是否也是垃圾回收的对象？？？</p>
</li>
<li><p>Java的<code>Static area</code>与<code>Heap area</code>的问题。在读入class时使用的两种内存领域。static修饰的变量和方法放在static领域中，因此不需要创造instance也可以直接使用。当对一个class中的static变量进行值的变更时，会直接影响到那个class的static变量的值。</p>
</li>
<li><p>static修饰的方法，只能访问static修饰的变量或者方法。</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>返回值接收时只能是同一类型或者是有互换性的值。</p>
</li>
<li><p>略</p>
</li>
<li><p>可变长参数的问题。使用可变长参数时必须遵循两个原则：</p>
<ol>
<li>对于可变长参数。必须要是相同类型的集合，因为JVM传参时会把他们以数组的形式传进去。</li>
<li>当参数除了可变长参数之外还有其他参数时，可变长参数一定要放到参数的最后！！</li>
</ol>
</li>
<li><p>略</p>
</li>
<li><p>overload的定义。必须要是参数的数量，类型，顺序不同，且返回值类型相同的同名方法才算是overload。</p>
</li>
<li><p>当有两个同名函数，且参数的数量相同时，如果代入函数的参数有暧昧的性质时，JVM因为不知道应该选择哪个函数执行会出现编译错误。</p>
</li>
<li><p>只有访问修饰词不同的两个函数不能算overload（<code>public string test()&#123;&#125;</code>和<code>private string test()&#123;&#125;</code>就不能算重载）。</p>
</li>
<li><p>构造方法也是方法的一种，因此可以对构造方法进行重载。构造方法的三个rule为：</p>
<ol>
<li>构造方法必须与类名同名。</li>
<li>不能有返回值类型</li>
<li>只能与<code>new</code>关键字同时使用。因此，构造方法的访问关键字没有要求，即使是<code>private</code>也是可以的。例如可以在类中定义一个static的方法，在方法中调用<code>private</code>的构造方法并返回。有时，还会存在一个类有两个访问权限不同，参数不同的构造方法同时存在，可以由外部调用公开的构造方法，再在公开的构造方法中对私有的构造方法进行调用，达到保护内部信息的目的。</li>
</ol>
</li>
<li><p>判断函数是不是构造方法时看有没有写返回值类型（尤其是<code>void</code>！！）。</p>
</li>
<li><p><a href="https://blog.csdn.net/sswqzx/article/details/85684980">构造代码块</a>的问题。构造代码块和构造函数同时出现时，要记住构造代码块一定在所有的构造函数之前被执行。</p>
</li>
<li><p>static的变量是在instance生成之后才能被初始化的，因此在构造代码块和构造函数中无法对它的值进行初期化。如果想在instance生成前对static的类变量进行初始化处理，可以使用static的构造代码块。例如下面的例子，在instance生成前num的值就是10了。</p>
<ol>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    num = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sample</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>当类中有自己定义的有参数的构造方法时，无参的构造方法就不会被自动引入。（判断同名的方法是不是构造方法是关键！！）</p>
</li>
<li><p>当一个构造函数中想使用同一个类的其他构造函数时要使用<code>this（另外构造函数的参数）</code>。</p>
</li>
<li><p>24问题的后续，在一个构造方法中使用this叫另外的构造方法时，必须在最开始使用，如果在这个this前有别的处理，编译时候会报错.例如这样就会报错。</p>
<p>public class This {</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">This</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">This</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">this</span>(<span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">This</span><span class="params">(String str, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">This</span><span class="params">(<span class="keyword">int</span> num, String str)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;not ok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于访问修饰词权限的问题，<a href="https://blog.csdn.net/qq_33642117/article/details/52166121">参考这里</a>。</p>
</li>
<li><p>关于访问修饰词权限的问题，<a href="https://blog.csdn.net/qq_33642117/article/details/52166121">参考这里</a>。</p>
</li>
<li><p>因为要防止其他的类对自己的变量进行出乎自己意料的更改，所以需要将变量private，方法public，又名胶囊化。</p>
</li>
<li><p>当函数的参数是原始类型（プリミティブ型）时，函数被呼出时，参数是从呼出的地方被拷贝到函数本身去的。不会对传入的instance造成影响。</p>
</li>
<li><p>当函数的参数是object类型时，函数被呼出时，被拷贝的是指向instance的link。因此可能会对原本的instance产生影响。因此，函数的参数是原始类型（プリミティブ型）还是参照类型，非常关键！！！！！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第八章)</title>
    <url>/2020/08/08/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E5%85%AB%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第八章-関数型インタフェース、ラムダ式"><a href="#第八章-関数型インタフェース、ラムダ式" class="headerlink" title="第八章 関数型インタフェース、ラムダ式"></a>第八章 関数型インタフェース、ラムダ式</h4><p>間違えた：1，3， 4， 6，7，8</p>
<p>間違えし易い：</p>
<p>分からない：5，6， </p>
<p>关键词：lamada式，<a href="https://www.jianshu.com/p/a59a31eb3a41">匿名类</a>，<a href="https://www.jianshu.com/p/86badf2c46c3">函数型接口</a>, </p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li><p>lamda式的格式：</p>
<p><code>（变量名参数） -&gt; &#123;处理&#125;;</code>注意，最后要加分号！！</p>
<p>函数型接口中定义的方法的参数定义和lamda式中的参数定义必须相同。并且lamda式的参数可以省略参数的类型。因为可以使用代入的函数型接口来推断参数的类型。如果函数型接口中的方法定义的时候是无参数的（例如<code>Runnable</code>），可以省略lamda式中的参数。</p>
</li>
<li><p>在<code>函数型接口的类型 变量名 = （变量名参数） -&gt; &#123;处理&#125;;</code>中：</p>
<ol>
<li>当参数只有一个时，的实际上右边的lamda式可以省略为：<code>函数型接口的类型 变量名 = 参数 -&gt; &#123;处理&#125;;</code></li>
<li>当实现的处理只有一行时，中括号也可以省略：<code>函数型接口的类型 变量名 = （变量名参数） -&gt; 处理;</code></li>
<li>需要返回的情况下，当实现的处理只有一行，且省略了中括号的情况下，<code>return</code>关键字可以省略。</li>
<li><code>Test t = () -&gt; return &quot;hello!&quot;</code>会报编译错误。相反如果有中括号，一定是有1行以上的处理，且一定不可以省略<code>return</code>关键字。</li>
</ol>
</li>
<li><p>lamda式中参数不能使用定义lamda式方法中已有的参数的名字，会造成重复定义，例如下面的代码会报编译错误，因为在第三行相当于进行了val字符串的重复定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String val = A;</span><br><span class="line">  Function f = (val) -&gt; &#123;</span><br><span class="line">    System.out.println(val);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于lamda式的scope问题,lamada可以访问同一方法中定义的其他本地变量，但是变量一定要是实质上final的也就是在lamda式后面值也不能改变，<a href="https://www.jianshu.com/p/ade870238d18">参考这里</a>，下面的代码不会报错，但是如果第8行注释取消就会在第5行报编译错误。因为val变量不再是实质final</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lamdaScope</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String val = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        Function f = (nothing ) -&gt; &#123;</span><br><span class="line">            System.out.println(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//        val = &quot;Hello World!!&quot;;</span></span><br><span class="line">        System.out.println(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>java.util.function</code>中定义好的函数型接口的问题。<a href="https://www.jianshu.com/p/86badf2c46c3">参考这里</a>，由于有参数并且返回值是Boolean类型的可以使用排除法去掉<code>Consumer&lt;T&gt;</code>和<code>Supplier&lt;T&gt;</code>， 最后因为参数只有一个可以排除<code>Function&lt;T, R&gt;</code>。</p>
<table>
<thead>
<tr>
<th align="center">函数式接口</th>
<th align="center">参数类型</th>
<th align="center">返回类型</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Consumer&lt;T&gt;</code>(消费型接口)</td>
<td align="center"><code>T</code></td>
<td align="center"><code>void</code></td>
<td align="center">对类型为T的对象应用操作。<code>void accept(T t)</code></td>
</tr>
<tr>
<td align="center"><code>Supplier&lt;T&gt;</code>(供给型接口)</td>
<td align="center"><code>无</code></td>
<td align="center"><code>T</code></td>
<td align="center">返回类型为T的对象。 <code>T get();</code></td>
</tr>
<tr>
<td align="center"><code>Function&lt;T, R&gt;</code>(函数型接口)</td>
<td align="center"><code>T</code></td>
<td align="center"><code>R</code></td>
<td align="center">对类型为T的对象应用操作并返回R类型的对象。<code>R apply(T t);</code></td>
</tr>
<tr>
<td align="center"><code>Predicate&lt;T&gt;</code>(断言型接口)</td>
<td align="center"><code>T</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">确定类型为T的对象是否满足约束。<code>boolean test(T t);</code></td>
</tr>
</tbody></table>
</li>
<li><p><code>Supplier&lt;T&gt;</code>的使用相关问题。参照上表。</p>
</li>
<li><p><code>Function&lt;T, R&gt;</code>的使用，<code>java.util.function</code>中定义的基本函数型接口中，参数有两个的只有<code>Function&lt;T, R&gt;</code>，其中第一参数用泛型表示可以接收任何类型的参数，第二参数表示返回值的类型。</p>
</li>
<li><p>关于<code>Consumer&lt;T&gt;</code>(消费型接口)相使用的问题。<a href="https://www.jianshu.com/p/0b955173045e">参照这里</a>。</p>
</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://juejin.im/post/6844903892166148110#heading-0">「Java8系列」神奇的函数式接口</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第十一章)</title>
    <url>/2020/08/16/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第十一章-モジュールシステム"><a href="#第十一章-モジュールシステム" class="headerlink" title="第十一章 モジュールシステム"></a>第十一章 モジュールシステム</h4><p>間違えた：1，4，6</p>
<p>間違えし易い：</p>
<p>分からない： 1，2，3，4，5，6，7</p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li><p>module系统存在的意义。可以更方便的管理需要公开的包和不想公开的包。<code>module-info.java</code>中记述的内容为以下两条：</p>
<ol>
<li>要公开哪个包</li>
<li>要使用其他的哪个module</li>
</ol>
<p>另外需要注意，<code>module-info.java</code>的生成位置，写法为<code>module hello &#123;&#125;</code>。module之后的是module的名字，如果中括号里什么都不写，意味着任何包都不公开，也不利用任何的外部module。为了实现模组化需要将<code>module-info.java</code>与source code一起编译。编译文件的保存地址为mods文件夹。</p>
<p>编译命令：<code>javac -d classfile的保存目录 需要编译的文件的目录</code>。因此第二参数需要包含<code>module-info.java</code>文件的路径和想要编译的源代码的路径。</p>
</li>
<li><p>关于module的运行问题。命令:<code>java --module-path module文件路径 -m 要运行的module class</code>。当想运行有被module包含的class时，需要在module和想要运行的class的完全修饰名之间加上<code>/</code>。<br>例如 ：<code>java --module-path mods -m hello/com.sample.Main</code></p>
</li>
<li><p>module的公开设定相关。例如在test module中设置需要公开的包时需要在<code>module-info.java</code>中这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test&#123;</span><br><span class="line">  <span class="keyword">exports</span> com.test; <span class="comment">//记述需要公开的包。不写的默认为非公开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果hello module想要利用test中的方法，需要在自己的<code>module-info.java</code>中做如下记述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello &#123;</span><br><span class="line">  <span class="keyword">requires</span> test; <span class="comment">//使用requires来引入自己想利用的module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：更改完成后需要重新编译。</p>
</li>
<li><p>关于各个module之间的依存关系问题。当module1依存module2，module2依存module3时，module1是无法使用module3中的类的。因为module2中引入的包，是为了module2而引入的，如果想在module1中也能使用的module3的类，需要在module2中做出如下的设置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> module2 &#123;</span><br><span class="line">  <span class="keyword">requires</span> transitive module3; <span class="comment">//transitive是推移的意思，意味着在module1中也可以使用module3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://juejin.im/entry/6844903501311524871">参考这里</a>。关于java內建的module。都被归纳到java.base module中，这个module即使不用requires声明会被直接代入。</p>
</li>
<li><p>关于确认module的命令，想要确认一个module公开了什么包，依存了什么包，不需要<code>module-info.java</code>也可以确认，可以使用这两个命令:</p>
<ol>
<li><p>java命令的 <code>--describe-modue</code>选项  例：<code>java --module-path mods --describle-module foo</code> </p>
</li>
<li><p>jmod命令的<code>describe</code>模式                例：<code>jmod create -class-path mods/foo foo.jmod</code>生成jmod文件后，使用<code>jmod describe foo.jmod</code>查看</p>
<p>jdeps命令是用来查询类和方法，jar文件，module的依存关系的命令。（module的包公开信息不能通过此命令查询！！）</p>
<p>java命令的 <code>--show-module-resolution</code>是用来表示查看程序运行时怎样寻找依存module的option。</p>
</li>
</ol>
</li>
<li><p>关于非公开包的一时利用的问题。通过使用<code>javac</code>命令的<code>--add-exports</code>选项可以在编译时将想利用的包一时公开，被别的module可以利用。写法： 对象module/公开的包=利用的module 例如：-add-exports foo/com.test=hello</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第十章)</title>
    <url>/2020/08/15/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E5%8D%81%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第十章-例外処理"><a href="#第十章-例外処理" class="headerlink" title="第十章 例外処理"></a>第十章 例外処理</h4><p>間違えた：3，7，10，11，12，14，17</p>
<p>間違えし易い：</p>
<p>分からない： </p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li>略</li>
<li>略</li>
<li>父类异常一定要写在子类异常的下面1，否则父类异常就会被先捕捉导致子类异常无法到达，出现编译错误。</li>
<li>略</li>
<li>finally中的代码一定会执行，即使是catch中有return的情况下。</li>
<li>finally权限最大，当catch和fianlly中都有return时，finally中的return会被执行。</li>
<li>不懂？return中返回的是一个变量？finally不能对那个变量进行操作？</li>
<li>一个try只能对应一个finally，但是可以对应多个catch，并且catch可以省略</li>
<li>嵌套的try catch文中如果有异常，最接近异常的那层try catch将会捕捉异常。</li>
<li>try中声明的变量，catch和finally中不能访问。try-with-resources的运行顺序是<ol>
<li>resource中的释放</li>
<li>catch中的处理</li>
<li>finally的处理</li>
</ol>
</li>
<li>检查例外（Exception以及继承它的子类（除去RuntimeException））和非检查例外（RuntimeException以及继承它的子类）的区别。检查例外必须要用try catch围起来，或者是必须用throws宣言。而非检查例外就不需要强制，可以自由选择。多个例外throws是用逗号分隔</li>
<li>Error为了分类，是可以继承Errors类的。常见的例如<code>OutOfMemoryError</code>,<code>NoClassDefFoundError</code>。Error是在程序运行时被抛出的。但是也可以被throw-catch或者throws。</li>
<li>略</li>
<li>ArrayList的越界访问时丢出的是<code>IndexOutOfBoundException</code>。数组越界访问异常是<code>ArrayIndexOutOfBoundException</code>。文字越界异常是<code>StringIndexOutOfBoundException</code>。不存在<code>ListIndexOutOfBoundsException</code>这样的例外。</li>
<li>没有继承或者实现关系の1两个类强制转型时候，运行时会报<code>ClassCastException</code>。强制转型前应该使用<code>instanceof</code>进行判断。</li>
<li>null是无参照的，因此null使用方法时会报空指针异常。</li>
<li>因为会发生嵌套引用，用尽stack空间，所以会报StackOverflowError。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Sliver学习笔记(第四章)</title>
    <url>/2020/07/18/JavaSE11sliver%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E5%9B%9B%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 sliver资格考试相关</p>
</blockquote>
<a id="more"></a>



<h4 id="第四章-制御構造-二次"><a href="#第四章-制御構造-二次" class="headerlink" title="第四章 制御構造 (二次)"></a>第四章 制御構造 (二次)</h4><p>間違えた：3，4，13</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><ol>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>while后面不加括号时，运行的只有一行（行以<code>；</code>去区分）。<code>do while</code>后面不写中括号是，如果do的后面有多行代码，会报编译错误。</p>
</li>
<li><p>for的第一个初始化可以初始化多个变量，但是要求必须是同一类型，否则就会报编译错误。</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>for中的条件只能有一个，如果写了多个会报编译错误，如果想使用多个条件同时判断是可以使用<code>&amp;&amp;</code>。</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
<li><p>for可以省略条件表达式。</p>
</li>
<li><p>除了数组，ArrayList也可以使用扩张for(collection类继承了<code>java.lang.Iterable</code>)。</p>
</li>
<li><p>略</p>
</li>
<li><p>while的条件虽然判断失败，但是变量的自增也会完成。</p>
</li>
<li><p>如果有双重for循环，break能中断的只有最内层的。</p>
</li>
<li><p>continue只是跳过之后的处理，不会中断循环。</p>
</li>
<li><p>label可以写入的地方：</p>
<ol>
<li><p>code block（用<code>&#123;&#125;</code>括起来的代码）</p>
</li>
<li><p>所有的循环或者条件判断（if和switch）</p>
</li>
<li><p>式子，例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>; </span><br><span class="line">d: x = <span class="number">2</span>; </span><br><span class="line">e: System.out.println(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>代入</p>
</li>
<li><p>return</p>
</li>
<li><p>try block</p>
</li>
<li><p>throw</p>
</li>
</ol>
</li>
<li><p>当break和continue配合label使用时一定要确认代码的跳转位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Sliver</tag>
      </tags>
  </entry>
  <entry>
    <title>我们都爱cheese！！🧀</title>
    <url>/2020/07/26/%E6%88%91%E4%BB%AC%E9%83%BD%E7%88%B1cheese/</url>
    <content><![CDATA[<blockquote>
<p>记录一下我吃过的cheese（定期更新）</p>
</blockquote>
<p>最近沉迷在超市搜集各种各类的奶酪，晚上看着电影开一瓶红酒就着奶酪喝个微醺就去睡觉，睡眠质量也提升了不少，趁着闲来无事，把吃过的简单做个评价介绍，踩坑也好运气爆棚也好，总能留下来个印象。</p>
<a id="more"></a>

<br>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4k9egsqmg30dw08c163.gif" alt="It&#39;s an all-consuming love_"></p>
<p>如题，我们都爱cheese！！开一个post记录一下最近吃的奶酪们🧀~~</p>
<br>

<p>先来一款黑暗的，蓝纹奶酪，貌似意大利语中“piccante”是辛辣的意思。这款不适合喝酒，味道太辛辣，适合小口小口的吃。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4ifzccmaj30u00u07wj.jpg" alt="piccante" style="zoom:33%;" />

<br>

<p>这款是我目前吃过最好吃的，有一点像布里，有一点像卡芒贝尔。但是外面的白色霉菌质感还是不太一样，不太清楚学名叫什么，口感非常棒，适合搭配红酒。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4ieyi57ej30u00u0kjo.jpg" alt="beili" style="zoom: 33%;" />

<br>

<p>德国经典品牌Bergader的蓝纹奶酪，不用多说，喜欢蓝纹的可以一试，性价比超高。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4ijvdt1yj30u00u0npf.jpg" style="zoom: 33%;" />

<br>

<p>日本品牌雪印的卡芒贝尔奶酪，卡芒贝尔也算是我非常喜欢的一个品类。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4im3pur6j30u00u01l0.jpg" alt="camembert" style="zoom:33%;" />

<br>

<p>又一款布里，产自法国，白色霉菌包裹的内部层次感非常好。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4inyo45tj30u00u04qs.jpg" alt="brie" style="zoom:33%;" />

<br>

<p>日本超市随处可见的轻食奶酪，味道很好，尤其左边的这款马苏里拉奶酪，嫩的不行。性价比超高。基本上都在150日元（9RMB）以内。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4ipcq8rqj30u00u0b2c.jpg" alt="little" style="zoom:33%;" />











]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>我当社会人8个月啦（技术篇）</title>
    <url>/2020/12/29/%E6%88%91%E5%BD%93%E7%A4%BE%E4%BC%9A%E4%BA%BA8%E4%B8%AA%E6%9C%88%E5%95%A6/</url>
    <content><![CDATA[<blockquote>
<p>四月到十二月，我已经成为社畜八个月了。</p>
</blockquote>
<p>听到“社会人”这个词让你想到什么？纹龙画虎的大哥？亦或是一天三顿烧烤的东北汉子？其实这个词在日语中，指的是朝九晚五，兢兢业业上班族。弹指一挥间，我成为“社会人”也八个月了。</p>
<a id="more"></a>

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm4q58jaogj30u00u03zi.jpg" alt="6591609224392_.pic" style="zoom: 50%;" />

<br>

<p>2020年马上就要过去了，东京的新冠依然保持着每日几百的增长速度，在家堵得无聊，就流水账般的记录一下自己上班这八个月吧。</p>
<p>先谈谈工作内容。</p>
<p>4月到7月是漫长的研修，研修内容就是日企都有的那一套，就不提了。7月份结束研修，分到配属的部门，不出意外的做的是java开发。其实一开始自己是想做点比较热门的内容，没想到也变成了茫茫java程序员中的一员。或许这就是命运的安排吧。</p>
<p>来日本一开始想做的是大数据方向，研究室那会以为老师是做大数据的，进去后才发现是关系数据库。怪自己那会的日语水平太渣。。关系数据库的内部说深奥是真深奥，个人感觉单放现在的研究趋势真的是过时了一点，感觉现在的热门就是AI，数据分析什么的，貌似好多大公司都用OSS的数据库？所以自己后来做的是GPU计算方向，跟现在的的工作内容也算是毫不沾边，感觉去年还在特别努力学习的知识慢慢的就会被遗忘。。可能世界上多数的研究生都是这样吧。</p>
<p>言归正传，我所在的部门一共10人左右，除了管理职的课长和一个中途入社的以外全是1年和2年的，可以说是非常年轻的部队了。也可以说除了课长，都是年轻的程序员。部门采用的是敏捷开发的一种叫做scrum的开发模式，其实具体都是学欧美那一套，2周为周期给一个项目做一些功能增加或者修改。然后团队都是比较少人数便于管理。这种开发模式希望开发团队的每个人都是“多能工”，也就是俗称的全栈工程师。因为项目的设计开发测试以及前端后端实现都是同一个团队在做，需要的知识就会范围广一点。</p>
<p>我没在国内的IT公司正式上过班，但我来日本前在北京的一个小创业公司呆过一阵，感觉日本这边和中国不同的就是，日本的好多公司都很重视人才培养，国内更喜欢直接采用有技术的人。但是日本这种模式就导致，好多人没有一点基础，也考虑来做IT的工作，和我同部门的新人，好多人刚来时一些基本的linux操作也不是很熟练，或者java完全是0基础。而我在的部门这种开发模式又要求掌握知识的范围广，这就导致一个问题。只有不断的学习才能做好业务！</p>
<p>刚进这个部门，每个人就被发了15本左右厚厚的书，让我们回家去看（当然，要用自己的业余时间）。至今为止我也只看完了4本左右，课长还因为这个经常说我们新人没有斗志，无所谓了，哈哈。这个部门还要求新人尽快考下三个资格（java Slive, java Gold和一个关于敏捷开发的资格）。目前我正在为取得最后一个java Gold的资格而奋斗中。。</p>
<br>

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm4ryd8j6xj31hc0u07ak.jpg" alt="6601609228101_.pic" style="zoom: 33%;" />                

<p>​                                <center>发的书中的一部分</center></p>
<p> 一开始还感觉工作的内容会不会很难掌握，其实目前工作的好多东西就是基本的CRUD，大量的重复工作。我也最近吗慢慢的体会到为什么程序员这行被称作“码农”。基础的程序员的工作确实是大量的重复，基本上写的逻辑不会很复杂，站在这个层面上的程序员基本上就需要熟练地使用一些api，在知乎上一个博主的话我觉得很有意思，他称这种人为”Api caller”，也是挺有趣的。这种工作中比拼的就是一个词“效率”。同样的一个查询处理，你需要三小时，别人只需要1小时，那么这个差异就体现出来了。但是，请注意，这个熟练度的东西，是任何人都可以练出来的，俗话熟能生巧，不会有很大的差异。</p>
<p>我们所在的项目前端用到一些js，js这个东西我的水平就是边查边写，我们组多数人感觉也是这样，大家都是瞎猫碰死耗子，感觉就是copy and paste coder，其实我还是很想系统的学习一下这门语言的。自己做的另外一个项目用到了Vue，慢慢对前端产生了兴趣，但平时工作中实在是没有人带，感觉学习一个东西，最好是有一个前辈能传授一些经验，或者是项目中有一些值得学习的东西，否则只能是自己啃书本了。</p>
<p>现在这个公司，其实最令我感到惊讶的一点是，这个大的部门中，像我们组一样自己开发做东西的，其实是凤毛麟角，多数部门都是外包给别的公司，或者采用一种日语叫“業務委託”的开发模式，简单说就是交给别的人去做，自己只负责写一写企划书，详细的功能要求之类的。大体比率来讲，自己开发的部门可能只占这个大部门的10%。这点可能国内的很多人都不太理解，包括我一开始也是很费解，光是做这些工作，不需要开发就能挣钱，并且实际上写代码的人的薪水还不如管理的高。这就牵扯到另外一个事实了，可能在国内程序员是妥妥的高薪职业。但在岛国却并不是。</p>
<p>本来我觉得我就读的庆应大学也算是日本名校，可能在国内来讲最少也是一个985高校的水平。大家可以想象一下985的研究生一般努努力都去了什么公司呢，BAT，美团，字节跳动这类比较多对不对。感觉刚出来就是20k的月薪，虽然程序员这行有着996的传闻，但是看着那白花花的银子，也是真香定理对不对？但在岛国，学历在找工作的时候却并没有绝对的优势。我的同事有一般本科毕业的，我所在的部门就有两个高专毕业的。薪水也没有差很多。跟我最初想象的读个名校然后拿着高于平均线一大截的薪水截然不同好吗，哈哈。</p>
<p>感觉说了一大堆，中心思想也没有很明确，自己的中文写作能力是越来越差了，还是总结一下目前的苦恼吧，看来得分几篇来写了。开一个新坑吧。</p>
<ol>
<li>加班不断，基本上每天回家也是10点了。</li>
<li>团队技术问题，没有真正的大神镇场子，好多东西都是靠谷歌，虽说善用谷歌是好事，但是一些问题还是需要有经验者前期纠正。</li>
<li>成长有天花板，部门比较年轻，采用的技术栈是否与外界有脱轨，尚不明确。</li>
</ol>
<p>关于这三点，下篇我再有针对性的仔细分析一下。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>myfirstblog</title>
    <url>/2020/05/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
    <content><![CDATA[<p>终于下定决心要做一个自己的博客了，用来记录一点生活的碎片。</p>
]]></content>
  </entry>
  <entry>
    <title>生活杂记</title>
    <url>/2020/07/05/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>2020已经过去一半了。。。</p>
</blockquote>
<p>4月入职开始，不知不觉已经在家工作了三个月了，加上今年1月从国内回来后在打工的公司就是在宅勤务，我觉得可能我已经不适应在公司的节奏了。想到拥挤无比的山手线，新桥站慢无表情的工薪族人潮，就有种莫名其妙的惶恐。</p>
<a id="more"></a>

<p>想起之前看过藤子不二雄老先生的一个短篇漫画，成为新卒却畏惧上司和职场文化的主人公每天离开家后，假装去上班缺来到公司附近的一个公园，一坐就是一天。故事的结局记不清了，但想必跟我一样不喜欢处理复杂人际关系的人比比皆是吧。</p>
<p>一直以来总想写点东西记录自己，包括学习的东西，生活的点滴，之前尝试过写过公众号，写了几篇文章后感觉到但还是觉得作为一个码农，应该有一个自己的博客，关于技术的文章还是应该用markdown去写，这个博客也是搭建了好久，嫌markdown插入图片麻烦，之前写的学习总结都放在google文档里了。考虑到共享精神，希望以后自己可以慢慢全部转成markdown格式copy到这里来。（又一个拖延flag）</p>
<p>因为疫情，以前好多节奏性的生活模式都被改变了，我已经好久没有去唱片店淘东西，也几乎没能约朋友出来玩了。最近唯一的乐趣的就是每天晚上尽量都会去看一篇电影。上班后就越来能体会到一个道理，时间也是一种资产，每个人对资产的投资直接导致了今后的回报。倘若你喜爱技术，每天下了班还花三个小时去看技术书籍，你以后一定会成为技术大牛；如果你喜欢美剧英剧，每天花上三小时看看剧，没准你得英语也会越来越好，直接开辟一个新的职业道路；就算你每天花上三个小时发呆打盹什么都不干，也许你能过上一个没有心理压力非常悠闲的生活。。但我可能是更偏向于喜欢分散投资的类型？？</p>
<p>喜欢技术但我一直觉得技术应该是用来解决问题，想要去掌握一门技术应该是对解决一个问题有了需求，而不是追求趋势，人云亦云，现在这个信息爆炸的时代改变了好多人的思维模式，学习东西仿佛变成了大家都在学所以我要去学，而不是我想知道为什么这个事情会这样，我想去解决这个我关心的问题，这个工具应该可以解决这个问题，所以我觉得这个工具值得我去学习。</p>
<p>貌似有点扯偏了，不过也无所谓，本来这个博文就是生活杂记，单纯的敲敲键盘把自己一闪而过的点子胡乱的记下来就算达成目的。最后给大家推荐一部前天晚上看过的电影吧。</p>
<p><img src="https://i.loli.net/2020/07/05/TRKL5jSQc8lwkHV.jpg" alt="爱尔兰人.jpg"></p>
<p>​                                                                                    《爱尔兰人》</p>
<p>如果你喜欢黑帮片，看到这个卡司还用我说什么吗？？？</p>
<p>剧情我就也不剧透了，这片的音乐也十分的带感。</p>
<p>影片有点长，分了两三次才看完的，但相信我，它值得你的时间。</p>
<p>好了，随随便便杂的要命的一篇水文就这么完了吧，自己的文笔真的是够臭的。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程入门</title>
    <url>/2021/01/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>Java多线程入门</p>
</blockquote>
<a id="more"></a>

<h3 id="1-创建新线程"><a href="#1-创建新线程" class="headerlink" title="1.创建新线程"></a>1.创建新线程</h3><p>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程；</p>
<p>一个线程对象只能调用一次<code>start()</code>方法；</p>
<p>线程的执行代码写在<code>run()</code>方法中；</p>
<p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p>
<p><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</p>
<h3 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2.线程的状态"></a>2.线程的状态</h3><p>Java线程对象<code>Thread</code>的状态包括：<code>New</code>、<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>、<code>Timed Waiting</code>和<code>Terminated</code>；</p>
<p>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束；</p>
<p>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</p>
<p>对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</p>
<h3 id="3-中断线程"><a href="#3-中断线程" class="headerlink" title="3.中断线程"></a>3.中断线程</h3><p>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</p>
<p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p>
<p>通过标志位判断需要正确使用<code>volatile</code>关键字；</p>
<p><code>volatile</code>关键字解决了共享变量在线程间的可见性问题。</p>
<h3 id="4-守护线程"><a href="#4-守护线程" class="headerlink" title="4.守护线程"></a>4.守护线程</h3><p>守护线程是为其他线程服务的线程；</p>
<p>所有非守护线程都执行完毕后，虚拟机退出；</p>
<p>守护线程不能持有需要关闭的资源（如打开文件等）。</p>
<h3 id="5-同步线程"><a href="#5-同步线程" class="headerlink" title="5.同步线程"></a>5.同步线程</h3><p>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过<code>synchronized</code>同步；</p>
<p>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</p>
<p>注意加锁对象必须是同一个实例；</p>
<p>对JVM定义的单个原子操作不需要同步。</p>
<h3 id="6-同步方法"><a href="#6-同步方法" class="headerlink" title="6.同步方法"></a>6.同步方法</h3><p> 没有特殊说明时，一个类默认是非线程安全的。</p>
<p>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code>；</p>
<p>通过合理的设计和数据封装可以让一个类变为“线程安全”；</p>
<p>一个类没有特殊说明，默认不是thread-safe；</p>
<p>多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。</p>
<h3 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a>7.死锁</h3><p>Java的<code>synchronized</code>锁是可重入锁；</p>
<p>死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；</p>
<p>避免死锁的方法是多线程获取锁的顺序要一致。</p>
<h3 id="8-使用wait或者notify"><a href="#8-使用wait或者notify" class="headerlink" title="8.使用wait或者notify"></a>8.使用wait或者notify</h3><p><code>wait</code>和<code>notify</code>用于多线程协调运行：</p>
<ul>
<li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li>
<li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li>
<li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li>
<li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li>
<li>已唤醒的线程还需要重新获得锁后才能继续执行。</li>
</ul>
<h3 id="9-使用ReentrantLock"><a href="#9-使用ReentrantLock" class="headerlink" title="9.使用ReentrantLock"></a>9.使用ReentrantLock</h3><p><code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步；</p>
<p><code>ReentrantLock</code>获取锁更安全；</p>
<p>必须先获取到锁，再进入<code>try &#123;...&#125;</code>代码块，最后使用<code>finally</code>保证释放锁；</p>
<p>可以使用<code>tryLock()</code>尝试获取锁。</p>
<h3 id="10-使用Condition"><a href="#10-使用Condition" class="headerlink" title="10.使用Condition"></a>10.使用Condition</h3><p>使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例。</p>
<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>
<ul>
<li><code>await()</code>会释放当前锁，进入等待状态；</li>
<li><code>signal()</code>会唤醒某个等待线程；</li>
<li><code>signalAll()</code>会唤醒所有等待线程；</li>
<li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li>
</ul>
<p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (condition.await(1, TimeUnit.SECOND)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 被其他线程唤醒</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 指定时间内没有被其他线程唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，使用<code>Condition</code>配合<code>Lock</code>，我们可以实现更灵活的线程同步。</p>
<p><code>Condition</code>可以替代<code>wait</code>和<code>notify</code>；</p>
<p><code>Condition</code>对象必须从<code>Lock</code>对象获取。</p>
<h3 id="11-使用ReadWriteLock"><a href="#11-使用ReadWriteLock" class="headerlink" title="11.使用ReadWriteLock"></a>11.使用ReadWriteLock</h3><table>
<thead>
<tr>
<th align="left">读</th>
<th align="left">写</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">读</td>
<td align="left">允许</td>
<td>不允许</td>
</tr>
<tr>
<td align="left">写</td>
<td align="left">不允许</td>
<td>不允许</td>
</tr>
</tbody></table>
<p>使用<code>ReadWriteLock</code>可以提高读取效率：</p>
<ul>
<li><code>ReadWriteLock</code>只允许一个线程写入；</li>
<li><code>ReadWriteLock</code>允许多个线程在没有写入时同时读取；</li>
<li><code>ReadWriteLock</code>适合读多写少的场景。</li>
</ul>
<h3 id="12-使用StampedLock"><a href="#12-使用StampedLock" class="headerlink" title="12.使用StampedLock"></a>12.使用StampedLock</h3><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p>
<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>
<p><code>StampedLock</code>提供了乐观读锁，可取代<code>ReadWriteLock</code>以进一步提升并发性能；</p>
<p><code>StampedLock</code>是不可重入锁。</p>
<h3 id="13-使用Concurrent集合"><a href="#13-使用Concurrent集合" class="headerlink" title="13.使用Concurrent集合"></a>13.使用Concurrent集合</h3><table>
<thead>
<tr>
<th align="left">interface</th>
<th align="left">non-thread-safe</th>
<th align="left">thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">List</td>
<td align="left">ArrayList</td>
<td align="left">CopyOnWriteArrayList</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">HashMap</td>
<td align="left">ConcurrentHashMap</td>
</tr>
<tr>
<td align="left">Set</td>
<td align="left">HashSet / TreeSet</td>
<td align="left">CopyOnWriteArraySet</td>
</tr>
<tr>
<td align="left">Queue</td>
<td align="left">ArrayDeque / LinkedList</td>
<td align="left">ArrayBlockingQueue / LinkedBlockingQueue</td>
</tr>
<tr>
<td align="left">Deque</td>
<td align="left">ArrayDeque / LinkedList</td>
<td align="left">LinkedBlockingDeque</td>
</tr>
</tbody></table>
<h4 id="14-使用线程池"><a href="#14-使用线程池" class="headerlink" title="14.使用线程池"></a>14.使用线程池</h4><p>JDK提供了ExecutorService实现了线程池功能：</p>
<p>线程池内部维护一组线程，可以高效执行大量小任务；</p>
<p>Executors提供了静态方法创建不同类型的ExecutorService；</p>
<p>必须调用shutdown()关闭ExecutorService；</p>
<p>ScheduledThreadPool可以定期调度多个任务。</p>
<p>创建一个<code>ScheduledThreadPool</code>仍然是通过<code>Executors</code>类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService ses &#x3D; Executors.newScheduledThreadPool(4);</span><br></pre></td></tr></table></figure>

<p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1秒后执行一次性任务:</span><br><span class="line">ses.schedule(new Task(&quot;one-time&quot;), 1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的每3秒执行，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2秒后开始执行定时任务，每3秒执行:</span><br><span class="line">ses.scheduleAtFixedRate(new Task(&quot;fixed-rate&quot;), 2, 3, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2秒后开始执行定时任务，以3秒为间隔执行:</span><br><span class="line">ses.scheduleWithFixedDelay(new Task(&quot;fixed-delay&quot;), 2, 3, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h3 id="15-使用Future"><a href="#15-使用Future" class="headerlink" title="15.使用Future"></a>15.使用Future</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<p><code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>
<h3 id="16-使用CompletableFuture"><a href="#16-使用CompletableFuture" class="headerlink" title="16.使用CompletableFuture"></a>16.使用CompletableFuture</h3><p>CompletableFuture的优点是：</p>
<p>异步任务结束时，会自动回调某个对象的方法；<br>异步任务出错时，会自动回调某个对象的方法；<br>主线程设置好回调后，不再关心异步任务的执行。</p>
<p><code>CompletableFuture</code>可以指定异步处理流程：</p>
<ul>
<li><code>thenAccept()</code>处理正常结果；</li>
<li><code>exceptional()</code>处理异常结果；</li>
<li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code>；</li>
<li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code>。</li>
</ul>
<h3 id="17-使用ThreadLocal"><a href="#17-使用ThreadLocal" class="headerlink" title="17.使用ThreadLocal"></a>17.使用ThreadLocal</h3><p>ThreadLocal表示线程的“局部变量”，它确保每个线程的ThreadLocal变量都是各自独立的；</p>
<p>ThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</p>
<p>使用ThreadLocal要用try … finally结构，并在finally中清除。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE 11 Gold学习笔记(第九章)</title>
    <url>/2021/01/23/JavaSE11Gold%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B9%9D%E7%AB%A0)/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 11 Gold资格考试相关</p>
</blockquote>
<a id="more"></a>



<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a><strong>知识点总结</strong></h2><p>❌⭕️</p>
<ul>
<li><h4 id="第九章-JDBCによるデータベース・アプリケーション"><a href="#第九章-JDBCによるデータベース・アプリケーション" class="headerlink" title="第九章 JDBCによるデータベース・アプリケーション"></a>第九章 JDBCによるデータベース・アプリケーション</h4></li>
</ul>
<p>間違えた：</p>
<p>間違えし易い：</p>
<p>分からない：</p>
<ol>
<li>C</li>
<li>C❌⭕️A<ol>
<li>需要根据使用的数据库自行设置对应的driver</li>
</ol>
</li>
<li>C</li>
<li>B❌⭕️D<ol>
<li>接触时使用的类和方法为<code>java.sql.DriverManager</code>和<code>getConnection</code></li>
<li>需要注意问题中使用的JDBC版本，不同版本使用方法稍有不同。例如3.0需要先获取driver</li>
<li>connection pool是在用作web application与数据库接触时，为了防止频繁的接触，切断而带来的性能瓶颈。事先准备的多个connection object。</li>
</ol>
</li>
<li>B</li>
<li>B❌⭕️BC<ol>
<li>要注意executeQuery和executeUpdate的使用区别</li>
</ol>
</li>
<li>D❌⭕️F<ol>
<li>使用getString方法时需要注意。根据index取得时是从1开始，根据列名取得时不区分大小写。</li>
<li>要注意cursor的初始位置是在先头record的上面，因此需要移动。如果不做移动就取得要素，会抛出SQLException</li>
</ol>
</li>
<li>C</li>
<li>B❌⭕️C<ol>
<li>execute的结果是当sql的结果是ResultSet不存在的情况或者sql是select以外的情况就返回fasle。</li>
</ol>
</li>
<li>A❌⭕️D<ol>
<li>同一个statement不能同时取得两个ResultSet。在取得第二个的时候第一个会被close。</li>
</ol>
</li>
<li>D</li>
<li>ADF❌⭕️ADE<ol>
<li>不存在forward方法。</li>
</ol>
</li>
<li>A absolute的参数如果比行数大，会移动到最终行后的空行</li>
<li>A❌⭕️D<ol>
<li>最终需要使用updateRow来更新</li>
</ol>
</li>
<li>C❌⭕️B<ol>
<li>插入时先使用moveToInsertRow移动到插入专用行，使用updateXxx进行数据的set，最后使用insertRow插入</li>
</ol>
</li>
<li>C<ol>
<li>通过分析ErrorCode和SQLState可以得到具体错误ErrorCode根据查询vendor手册可以获得具体讯息，SQLState是sql标准的共同值。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资格考试</tag>
        <tag>Java Gold</tag>
      </tags>
  </entry>
</search>
